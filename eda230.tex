\documentclass[a4paper,12pt, notitlepage]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{program}
\usepackage{color}

\renewcommand{\o}{\lor}
\newcommand{\gge}{\ \underline{\gg}\ }
\newcommand{\no}{\neg}
\newcommand{\eq}{\equiv}
\newcommand{\nq}{\not\equiv}
\newcommand{\tq}{\mid}
%\newcommand{\impl}{\Rightarrow}
\newcommand{\conseq}{\Leftarrow}
\newcommand{\existe}[3]{(\exists #1 \mid #2 : #3)}
\newcommand{\patodo}[3]{(\forall #1 \mid #2 : #3)}
\newcommand{\cgen}[4]{(#1 #2 \mid \ #3 : #4)}
\newcommand{\sust}[3]{#1 [#2 := #3]}
\newcommand{\nolibre}[2]{\no \textit{ocurre-libre}('#1', '#2')}
\newcommand{\range}[3]{#1 \leq #2 < #3}

\renewcommand{\iff}{\textbf{ iff }}

\newcommand{\ind}[1]{\hspace*{#1 cm}}
\newcommand{\negv}{\vspace{-0.7cm}}

\begin{document}

\begin{center}

{\Large{Study Guide\\ \bigskip
			Optimising Compilers @ Lunds Universitet}}
\vspace{1cm}
\end{center}
\section*{Basics}
\subsubsection*{Lattice}
It's a partially ordered set where every pair has least upper and greatest lower
bounds (infimum and supremum) which are unique. They are called the
\textit{meet} ($\land$) and \textit{join} ($\lor$), respectively.

\subsubsection*{Tarjan's algorithm for Strongly Connected Components}
\negv
\begin{program}
\PROC |tarjan|() \BODY
    |components| = |new Set|
    |dfsNumIndex| = 0
    |stack| = |new Stack|
    \FOREACH |vertex | v | in | V \DO
        \IF (|dfsNum|[v] = null) \AR*
            strongConnect(v)
        \FI \OD
\end{program} \negv
\begin{program}
\PROC |strongConnect|(|vertex | v) \BODY
    |dfsNum|[v] = |dfsNumIndex|
    |lowLink|[v] = |dfsNumIndex|
    |dfsNumIndex| \texttt{ += } 1
    |stack|.|push|(v)
    \FOREACH w | in | succ(v) \DO
        \IF (|dfsNum|[w] = null) \AR*
            |strongConnect|(w)
            |lowLink|[v] = min(|lowLink|[v], |lowLink|[w])
        \ELSIF (|dfsNum|[w] < |dfsNum|[v] \land |stack|.|contains|(w)) \AR*
            |lowLink|[v] = min(|lowLink|[v], |dfsNum|[w]) \FI
    \OD
    \IF (|lowLink|[v] = |dfsNum|[v]) \AR*
        |scc| = |new Set|
        \DOW
            w = |stack|.|pop|()
            |scc|.|add|(w)
        \ODW (w \not= v)
        |components|.|add|(|scc|)
    \FI
\end{program}

\section*{Dominance Analysis}
\subsubsection*{Compute dominance}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gge w $ \iff every path from $s$ to $w$ includes $v$. 
\\ $v$ \textbf{dominates} $w$.
\item $dom(w) = \{v \mid v \gge w\}$
\item $\gge$ is a partial order relation. 
\item $u \gge v$ \iff $u \gge p_i$ for every $p_i \in pred(v)$
\item $dom(w) = \{w\} \cup \displaystyle \bigcap_{p \in pred(w)} dom(p)$
\end{enumerate}
\vspace{-0.5cm}
\paragraph*{Algorithm}
\begin{program}
\PROC |computeDominance|() \BODY
    |dom|[s] = \{s\}
    \FOREACH |vertex | v | in | V | except | s \DO
        |dom|[v] = V \OD
    \WHILE |some dom|[v] | has changed| \DO
        \FOREACH |vertex | v | in | V | except | s \DO
            |dom|[v] = \{v\} \cup \displaystyle \bigcap_{p \in pred(v)} |dom|[p]
            \OD
    \OD
\end{program}
\subsubsection*{Lenguaer-Tarjan Algorithm (Dominator Tree)}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gg w $ \iff $v \gge w \land v \not= w$
\\ $v$ \textbf{strictly dominates} $w$.
\item $v \in dom(w) \land u \in dom(w) \Rightarrow u \gge v \lor v \gge u$
\item $v = iDom(w)$ \iff $v \gg w \land \patodo{u}{u \gg w}{v \not\gg u}$
\\ $v$ \textbf{is the immediate dominator of} $w$.
\item The graph of the reflexive and transitive closure of the dominance
relation is a  tree, called the dominator tree (DT). $(u,v) \in DT$ 
\iff $u = iDom(v)$.
\item $u \gge v$ \iff $dfsNum(u) \leq dfsNum(v) \land \\ 
dfsNum(v) \leq dfsNum(u) + numberOfDescendants(u)$
\item $v = sDom(w)$ \iff $v$ is the smallest vertex by $dfsNum$ such that there
is a path $(v, u_1, u_2, ..., u_{k-1}, w)$ with $dfsNum(u_i) > dfsNum(w)$.
\\ The semidominator is frequently equal to the immediate dominator.
\end{enumerate}

\paragraph*{Algorithm}
$parent$ is the parent in the DFS tree after calling $dfs()$.
\begin{program}
\PROC |lenguaerTarjan|() \BODY
    |emptyBuckets()|
    |setSdominatorsToSelf()|
    |dfs()|
    \FOREACH |vertex | v | in reverse | dfsNumber | order| \DO
        \FOREACH |predecessor | p | of | v \DO
            u = |ancestorWithLeastSdom(p)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[v])) \AR*
                |sDom|[v] = |sDom|[u] 
            \FI
        \OD
        |bucket|[|sDom|[v]].add(v)
        |ancestor|[v] = |parent|(v) 
        \FOREACH |vertex | b| in bucket|[|parent|(v)] \DO
            |remove b|
            u = |ancestorWithLeastSdom(b)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[b])) \AR*
                |iDom|[b] = u
            \ELSE
                |iDom|[b] = |parent|(v)
            \FI
        \OD
    \OD
    \FOREACH |vertex | v | except | s \DO
        \IF |iDom|[v] \not= |sDom|[v] \AR*
            |iDom|[v] = |iDom|[|iDom|[v]]
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |ancestorWithLeastSdom|(|vertex |w) \BODY
    |go through the ancestor chain of | w
    |return ancestor with the least sDom|
\end{program}

\section*{Loop Analysis}
\subsubsection*{Basics}
\begin{enumerate}
\item A loop is a subgraph of the CFG that is a strongly connected component
\item An entry loop is a vertex with a predecessor that is not in the loop
\item Irreducible loops have multiple entry points
\item Reducible or natural loops only have one entry point: the loop header. 
It dominates all other vertices in the loop.
\end{enumerate}
\negv
\begin{program}
\PROC |identifyNaturalLoops|() \BODY
    \FOREACH |back edge | (v, w) | of | G \DO
        \IF (w.|dominates|(v)) \AR*
            |search backwards all paths from | v | to | w.
            |the visited vertices belong to the natural loop|
        \FI
    \OD
\end{program}

\section*{Dataflow Analysis}
\subsubsection*{Basics}
\begin{itemize}
\item It is concerned with how a procedure uses and defines its variables and 
expressions
\item Every assignment statement is given an index
\item Local analysis discovers what happens within a vertex: its output is
$gen(v)$ and $kill(v)$
\item Global analysis: each vertex has $in(v)$ and $out(v)$ in addition to $gen$
and $kill$.
\end{itemize}
\begin{tabular}{ll}
$in(v)$ & definitions reaching the beginning of $v$ \\
$out(v)$ & definitions reaching the end of $v$ \\
$gen(v)$ & definitions generated in $v$ \\
$kill(v)$ & definitions killed in $v$ \\
\end{tabular}

\begin{program}
\PROC |reachingDefs|() \BODY
    |workList| = |vertices in reverse postorder|
    \WHILE |workList is not empty| \DO
        v = |workList|.|first|()
        |old| = |out|[v]
        |in|[v] = \displaystyle \bigcup_{p \in pred(v)} |out|[p]
        |out|[v] = |gen|[v] \cup (|in|[v] - |kill|[v])
        \IF (|old| \not= |out|(v)) \AR*
            \FOREACH |succesor | s | of | v \DO
                \IF (s | is not in workList|) \AR* 
                    |workList|.|add|(s)
                \FI
            \OD
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |localLiveAnalysis|() \BODY
    \FOREACH |vertex | v \DO
        \FOREACH |statement | s \DO
            \FOREACH |used variable | x | of | s \DO
                \IF (x \not\in |kill|[v]) \AR*
                   |use|[v].|add|(x)
                \FI
            \OD
            \FOREACH |defined variable | x | of | s \DO
                \IF (x \not\in |gen|[v]) \AR*
                   |kill|[v].|add|(x)
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |globalLiveAnalysis|() \BODY
    \WHILE |some in|[v] | has changed| \DO
        \FOREACH |vertex v | \DO
            |out|[v] = \displaystyle \bigcup_{s \in succ(v)} |in|[s]
            |in|[v] = |use|[v] \cup (|out|[v] - |kill|[v])
        \OD
    \OD
\end{program}

\section*{Static Single Assignment Form}
\begin{itemize}
\item Every variable is defined as most once (statically)
\item $\phi$-functions: one argument for each predecessor at some join vertices
\end{itemize}

\subsubsection*{Dominance Frontiers}
\paragraph*{Theory}
\begin{enumerate}
\item $DF(v) = \{w \mid \existe{p}{p \in pred(w)}{v \gge p \land v \not\gg w}\}$
\\ the \textbf{dominance frontier of vertex v}
\\ the set of vertices $w$ such that $v$ dominates a predecessor of $w$, but does
not strictly dominate $w$.
\item $DF_{local}(v) = \{w \in succ(v) \mid v \not\gg w\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(v) \not\gg w\}$
\item $DF(v) = DF_{local}(v) \cup 
    \displaystyle \bigcup_{w \in children(v)} DF_{up}(w)$
\item $DF_{local}(v) = \{w \in succ(v) \mid iDom(w) \not= v\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(w) \not= v\}$
\end{enumerate}

\paragraph*{Algorithm}
\begin{program}
\PROC |dominanceFrontiers|() \BODY
    \FOREACH | vertex | v | in a postorder traversal of DT | \DO
        |dominanceFrontier|[v] = |new Set|
        \FOREACH | vertex | w | in succ|(v) \DO
            \IF (|iDom|(w) \not= v) \AR*
                |dominanceFrontier|[v].|add|(w)
            \FI
        \OD
        \FOREACH | vertex | w | in children|(v) \DO
            \FOREACH | vertex | u | in dominanceFrontier|[w] \DO
                \IF (iDom(u) \not= v) \AR*
                    |dominanceFrontier|[v].|add|(u)
                \FI
            \OD
        \OD
    \OD
\end{program}
%Hashbased value number
%Global value numbering
%Ssa pre (partial redundancy elimination)
\end{document}
