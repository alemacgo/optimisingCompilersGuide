\documentclass[a4paper,12pt, notitlepage]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{program}
\usepackage{color}

\renewcommand{\o}{\lor}
\newcommand{\gge}{\ \underline{\gg}\ }
\newcommand{\no}{\neg}
\newcommand{\eq}{\equiv}
\newcommand{\nq}{\not\equiv}
\newcommand{\tq}{\mid}
%\newcommand{\impl}{\Rightarrow}
\newcommand{\conseq}{\Leftarrow}
\newcommand{\existe}[3]{(\exists #1 \mid #2 : #3)}
\newcommand{\patodo}[3]{(\forall #1 \mid #2 : #3)}
\newcommand{\cgen}[4]{(#1 #2 \mid \ #3 : #4)}
\newcommand{\sust}[3]{#1 [#2 := #3]}
\newcommand{\nolibre}[2]{\no \textit{ocurre-libre}('#1', '#2')}
\newcommand{\range}[3]{#1 \leq #2 < #3}

\renewcommand{\iff}{\textbf{ iff }}

\newcommand{\ind}[1]{\hspace*{#1 cm}}
\newcommand{\negv}{\vspace{-0.7cm}}

\begin{document}

\begin{center}

{\Large{Study Guide\\ \bigskip
			Optimising Compilers @ Lunds Universitet}}
\vspace{1cm}
\end{center}
\section*{Basics}
\subsubsection*{Lattice}
It's a partially ordered set where every pair has least upper and greatest lower
bounds (infimum and supremum) which are unique. They are called the
\textit{meet} ($\land$) and \textit{join} ($\lor$), respectively.

\subsubsection*{Tarjan's algorithm for Strongly Connected Components}
\negv
\begin{program}
\PROC |tarjan|() \BODY
    |components| = |new Set|
    |dfsNumIndex| = 0
    |stack| = |new Stack|
    \FOREACH |vertex | v | in | V \DO
        \IF (|dfsNum|[v] = null) \AR*
            strongConnect(v)
        \FI \OD
\end{program} \negv
\begin{program}
\PROC |strongConnect|(|vertex | v) \BODY
    |dfsNum|[v] = |dfsNumIndex|
    |lowLink|[v] = |dfsNumIndex|
    |dfsNumIndex| \texttt{ += } 1
    |stack|.|push|(v)
    \FOREACH w | in | succ(v) \DO
        \IF (|dfsNum|[w] = null) \AR*
            |strongConnect|(w)
            |lowLink|[v] = min(|lowLink|[v], |lowLink|[w])
        \ELSIF (|dfsNum|[w] < |dfsNum|[v] \land |stack|.|contains|(w)) \AR*
            |lowLink|[v] = min(|lowLink|[v], |dfsNum|[w]) \FI
    \OD
    \IF (|lowLink|[v] = |dfsNum|[v]) \AR*
        |scc| = |new Set|
        \DOW
            w = |stack|.|pop|()
            |scc|.|add|(w)
        \ODW (w \not= v)
        |components|.|add|(|scc|)
    \FI
\end{program}

\section*{Dominance Analysis}
\subsubsection*{Compute dominance}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gge w $ \iff every path from $s$ to $w$ includes $v$. 
\\ $v$ \textbf{dominates} $w$.
\item $dom(w) = \{v \mid v \gge w\}$
\item $\gge$ is a partial order relation. 
\item $u \gge v$ \iff $u \gge p_i$ for every $p_i \in pred(v)$
\item $dom(w) = \{w\} \cup \displaystyle \bigcap_{p \in pred(w)} dom(p)$
\end{enumerate}
\vspace{-0.5cm}
\paragraph*{Algorithm}
\begin{program}
\PROC |computeDominance|() \BODY
    |dom|[s] = \{s\}
    \FOREACH |vertex | v | in | V | except | s \DO
        |dom|[v] = V \OD
    \WHILE |some dom|[v] | has changed| \DO
        \FOREACH |vertex | v | in | V | except | s \DO
            |dom|[v] = \{v\} \cup \displaystyle \bigcap_{p \in pred(v)} |dom|[p]
            \OD
    \OD
\end{program}
\subsubsection*{Lenguaer-Tarjan Algorithm (Dominator Tree)}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gg w $ \iff $v \gge w \land v \not= w$
\\ $v$ \textbf{strictly dominates} $w$.
\item $v \in dom(w) \land u \in dom(w) \Rightarrow u \gge v \lor v \gge u$
\item $v = iDom(w)$ \iff $v \gg w \land \patodo{u}{u \gg w}{v \not\gg u}$
\\ $v$ \textbf{is the immediate dominator of} $w$.
\item The graph of the reflexive and transitive closure of the dominance
relation is a  tree, called the dominator tree (DT). $(u,v) \in DT$ 
\iff $u = iDom(v)$.
\item $u \gge v$ \iff $dfsNum(u) \leq dfsNum(v) \land \\ 
dfsNum(v) \leq dfsNum(u) + numberOfDescendants(u)$
\item $v = sDom(w)$ \iff $v$ is the smallest vertex by $dfsNum$ such that there
is a path $(v, u_1, u_2, ..., u_{k-1}, w)$ with $dfsNum(u_i) > dfsNum(w)$.
\\ The semidominator is frequently equal to the immediate dominator.
\end{enumerate}

\paragraph*{Algorithm}
$parent$ is the parent in the DFS tree after calling $dfs()$.
\begin{program}
\PROC |lenguaerTarjan|() \BODY
    |emptyBuckets()|
    |setSdominatorsToSelf()|
    |dfs()|
    \FOREACH |vertex | v | in reverse | dfsNumber | order| \DO
        \FOREACH |predecessor | p | of | v \DO
            u = |ancestorWithLeastSdom(p)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[v])) \AR*
                |sDom|[v] = |sDom|[u] 
            \FI
        \OD
        |bucket|[|sDom|[v]].add(v)
        |ancestor|[v] = |parent|(v) 
        \FOREACH |vertex | b| in bucket|[|parent|(v)] \DO
            |remove b|
            u = |ancestorWithLeastSdom(b)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[b])) \AR*
                |iDom|[b] = u
            \ELSE
                |iDom|[b] = |parent|(v)
            \FI
        \OD
    \OD
    \FOREACH |vertex | v | except | s \DO
        \IF |iDom|[v] \not= |sDom|[v] \AR*
            |iDom|[v] = |iDom|[|iDom|[v]]
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |ancestorWithLeastSdom|(|vertex |w) \BODY
    |go through the ancestor chain of | w
    |return ancestor with the least sDom|
\end{program}

\section*{Loop Analysis}
\subsubsection*{Basics}
\begin{enumerate}
\item A loop is a subgraph of the CFG that is a strongly connected component
\item An entry loop is a vertex with a predecessor that is not in the loop
\item Irreducible loops have multiple entry points
\item Reducible or natural loops only have one entry point: the loop header. 
It dominates all other vertices in the loop.
\end{enumerate}
\negv
\begin{program}
\PROC |identifyNaturalLoops|() \BODY
    \FOREACH |back edge | (v, w) | of | G \DO
        \IF (w.|dominates|(v)) \AR*
            |search backwards all paths from | v | to | w.
            |the visited vertices belong to the natural loop|
        \FI
    \OD
\end{program}

\section*{Dataflow Analysis}
\subsubsection*{Basics}
\begin{itemize}
\item It is concerned with how a procedure uses and defines its variables and 
expressions
\item Every assignment statement is given an index
\item Local analysis discovers what happens within a vertex: its output is
$gen(v)$ and $kill(v)$
\item Global analysis: each vertex has $in(v)$ and $out(v)$ in addition to $gen$
and $kill$.
\end{itemize}
\begin{tabular}{ll}
$in(v)$ & definitions reaching the beginning of $v$ \\
$out(v)$ & definitions reaching the end of $v$ \\
$gen(v)$ & definitions generated in $v$ \\
$kill(v)$ & definitions killed in $v$ \\
\end{tabular}

\begin{program}
\PROC |reachingDefs|() \BODY
    |workList| = |vertices in reverse postorder|
    \WHILE |workList is not empty| \DO
        v = |workList|.|first|()
        |old| = |out|[v]
        |in|[v] = \displaystyle \bigcup_{p \in pred(v)} |out|[p]
        |out|[v] = |gen|[v] \cup (|in|[v] - |kill|[v])
        \IF (|old| \not= |out|(v)) \AR*
            \FOREACH |succesor | s | of | v \DO
                \IF (s | is not in workList|) \AR* 
                    |workList|.|add|(s)
                \FI
            \OD
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |localLiveAnalysis|() \BODY
    \FOREACH |vertex | v \DO
        \FOREACH |statement | s \DO
            \FOREACH |used variable | x | of | s \DO
                \IF (x \not\in |kill|[v]) \AR*
                   |use|[v].|add|(x)
                \FI
            \OD
            \FOREACH |defined variable | x | of | s \DO
                \IF (x \not\in |gen|[v]) \AR*
                   |kill|[v].|add|(x)
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |globalLiveAnalysis|() \BODY
    \WHILE |some in|[v] | has changed| \DO
        \FOREACH |vertex v | \DO
            |out|[v] = \displaystyle \bigcup_{s \in succ(v)} |in|[s]
            |in|[v] = |use|[v] \cup (|out|[v] - |kill|[v])
        \OD
    \OD
\end{program}

\section*{Static Single Assignment Form}
\begin{itemize}
\item Every variable is defined as most once (statically)
\item $\Phi$-functions: one argument for each predecessor at some join vertices
\end{itemize}

\subsubsection*{Dominance Frontiers}
\paragraph*{Theory}
\begin{enumerate}
\item $DF(v) = \{w \mid \existe{p}{p \in pred(w)}{v \gge p \land v \not\gg w}\}$
\\ the \textbf{dominance frontier of vertex v}
\\ the set of vertices $w$ such that $v$ dominates a predecessor of $w$, but does
not strictly dominate $w$.
\\ if $v$ dominates a predecessor of $w$ but does not strictly dominate $w$,
    then $w$ is in the dominance frontier of $v$.
\item $DF_{local}(v) = \{w \in succ(v) \mid v \not\gg w\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(v) \not\gg w\}$
\item $DF(v) = DF_{local}(v) \cup 
    \displaystyle \bigcup_{w \in children(v)} DF_{up}(w)$
\item $DF_{local}(v) = \{w \in succ(v) \mid iDom(w) \not= v\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(w) \not= v\}$
\end{enumerate}

\paragraph*{Algorithm}
\begin{program}
\PROC |dominanceFrontiers|() \BODY
    \FOREACH | vertex | v | in a postorder traversal of DT | \DO
        |dominanceFrontier|[v] = |new Set|
        \FOREACH | vertex | w | in succ|(v) \DO
            \IF (|iDom|(w) \not= v) \AR*
                |dominanceFrontier|[v].|add|(w)
            \FI
        \OD
        \FOREACH | vertex | w | in children|(v) \DO
            \FOREACH | vertex | u | in dominanceFrontier|[w] \DO
                \IF (iDom(u) \not= v) \AR*
                    |dominanceFrontier|[v].|add|(u)
                \FI
            \OD
        \OD
    \OD
\end{program}

\subsubsection*{Insertion of $\Phi$-functions}
\paragraph*{Theory}
\begin{enumerate}
\item Two paths $p = (v_0, ..., v_X)$ and $q = (w_0, ..., w_Y)$
\textbf{converge} at $u$ \iff
    \begin{enumerate}
        \item $v_0 \not= w_0$
        \item $v_X = w_Y = u$
        \item $(u_i = v_j) \Rightarrow i = X \lor j = Y$
    \end{enumerate}
\item Given a set $A$ of vertices, the join of $A$ ($J(A)$) is the set of all
vertices $w$ such that there are two distinct vertices $u$ and $v$ in $A$ with
paths which converge at $w$.
\item $J_{i+1}(A) = J(A \cup J_{i}(A))$, $J^+(A)$ is the fixed-point.
\item $DF$ can be applied to sets of vertices, mapping $DF$ over all the
vertices of its argument.
\item $DF_{i+1}(A) = DF(A \cup DF_{i}(A))$, and $DF^+(A) = J^+(A)$.
\item The set of vertices which need $\Phi$-functions for any variable $v$
is the iterated dominance frontier $DF_+(A)$, where $A$ is the set of vertices
with assignment statements to $v$.
\end{enumerate}

\pagebreak
\paragraph*{Algorithm}
\begin{program}
\PROC |insert_|\Phi() \BODY
    |iteration| = 0
    \FOREACH | vertex | v \DO
        |hasAlready|[v] = 0
        |work|[v] = 0
    \OD
    W = |new Set|
    \FOREACH | variable | x \DO
        |iteration| \texttt{ += } 1
        \FOREACH | vertex | v \in A(x) \DO
            |work|[v] = |iteration|
            W.|add|(v)
        \OD
        \WHILE (W | is not empty|) \DO 
            v = |take vertex from | W
            \FOREACH w | in | DF(v) \DO
                \IF (|hasAlready|[w] < |iteration|) \AR*
                    |place | x = \Phi(x,...,x) | at | w
                    |hasAlready|[w] = |iteration|
                    \IF (|work|[w] < |iteration|) \AR*
                        |work|[w] = |iteration|
                        W.|add|(w)
                    \FI
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |renameVariables|() \BODY
    \FOREACH | variable | x \DO
        |C|[x] = 0
        |S|[x] = |new Stack|
    \OD
    |search|(s) \hspace{1cm} \texttt{// s = the start vertex}
\end{program}
\pagebreak
\begin{program}
\PROC |search|(|vertex | v) \BODY
    |oldLHS| = |new List|
    \FOREACH | assignment statement | s | in | v \DO
        \FOREACH | variable | x | in | RHS(s) \DO
            i = |S|[x].|top|()
            |replace use of | x | by use of | x_i
        \OD
        \FOREACH | variable | x | in | LHS(s) \DO
            |oldLHS|.|add|(x)
            i = |C|[x]
            |replace | x | by | x_i
            |S|[x].|push|(i)
            |C|[x] \texttt{ += } 1
        \OD
    \OD
    \FOREACH w | in | succ(v) \DO
        j = |which predecessor is v to w? | \hspace{1cm} \texttt{// first, second, ... ?}
        \FOREACH \Phi|-function in | w \DO
            i = |S|[x].|top|()
            |replace use of the | j |-th operand in | RHS(\Phi) | by use of | x_i
        \OD
    \OD
    \FOREACH w | in children|(v) \DO
        |search|(w)
    \texttt{// pop every variable version pushed in v}
    \FOREACH | variable | x | in | oldLHS(s) \DO
        |S|[x].|pop|()
    \OD
\end{program}

\section*{SSA Optimisation}
\subsubsection*{Partial Redundancy Elimination (PRE)}
\paragraph*{Basics}
\begin{itemize}
\item Attempt to calculate expressions only once
\item Partial redundancy: one of the expressions is inside an \texttt{if-else}
\pagebreak
\item Case examples
    \begin{enumerate}
        \item 
        \begin{verbatim}
if (a * b > max)
    max = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
if (t > max)
    max = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition)
    x = a * b
y = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    t = a * b
    x = t
}
else
    t = a * b
y = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \pagebreak
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition) {
    // some code
    y = x + 4
}
else {
    // other code
}
z = x + 4
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    // some code
    t = x + 4
    y = t
}
else {
    // other code
    t = x + 4
}
z = t
        \end{verbatim}
            
            

    \end{enumerate}
\item Loop improvement 
\item Global value numbering can optimise code that PRE cannot
\item Common subexpression elimination and code motion of loop invariants are
subsumed by PRE
\end{itemize}

\paragraph*{Theory}
\begin{enumerate}
\item Two operands $a_j$ and $b_k$ are equal \iff $a = b$
\item A computation $E_1$ at some point in the program is an occurrence of
computation $E$ if both perform the same operation and have equal operands
\item A computation $E$ is preserved along a path $P$ if $P$ contains nothing
that may alter the value of $E$.
\item If $E_1$ and $E_2$ are occurrences of $E$, and there is a path in the
program from $E_1$ to $E_2$ which preserves $E$, then $E_2$ is said to be
redundant with respect to $E_1$.
\item If $p$ is a point in the program and there is a path from $p$ to $E_1$
which preserves $E$ and contains no occurrence of $E$ between $p$ and $E_1$, 
$E_1$ is exposed with respect to $p$.
\item The set of occurrences to which $E_0$ is both redundant and exposed is
denoted $\Omega$.
\item The set of alterations of the value of $E$ is denoted $A$ (remember
        translation to SSA-form).
\item A vertex $v$ in $G$ is a $\Phi$-vertex for $E_0$ \iff
    \begin{itemize}
        \item The beginning of $v$ dominates $E_0$
        \item There exist distinct $u_1$, $u_2 \in \Omega \cup A$ and paths $p_1$ 
        and $p_2$ such that $u_1$ is contained in the first vertex of $p_1$, 
        $u_2$ is contained in the first vertex of $p_2$, and $p_1$ and $p_2$
        converge in $v$.
    \end{itemize}
\item An occurrence is \textbf{real} if it corresponds to code in the program,
    $\Phi$ if it is a $\Phi$-function.
\item A computation $E$ is partially available at point $p$ in the program if
there is a path from a real occurrence of the computation to $p$ that preserves
$E$.
\item A computation $E$ is fully available at point $p$ in the program if it is
partially available from every path from program entry $s$ to $p$.
\item An occurrence $E_0$ is partially redundant if $E$ is partially available
just before $E_0$
\item An occurrence $E_0$ is fully redundant if $E$ is fully available
just before $E_0$
\item The factored redundancy graph (FRG) of a computation $E$ is a directed
graph $FRG(N_{occ}, E_{up})$. The set of nodes consists of all real occurrences
of $E$ plus a $\Phi$ node for each $\Phi$-vertex of a real occurrence of $E$.
The edges in FRG are called upward edges and there is an upward edge in $E_{up}$
from each partially redundant real occurrence and partially redundant $\Phi$
operand occurrence to its representative occurrence.
\item Analogous: partially and fully anticipated
\item A placement is safe if all inserted real occurrences of a computation are
fully anticipated or fully available
\item A placement is computationally optimal if no safe placement can result in
fewer occurrences of the computation along any path from entry to exit in the
program
\end{enumerate}

\paragraph*{Algorithm} 
\begin{itemize}
\item \texttt{insert-$\Phi$}
\item \texttt{rename}
\item \texttt{downsafety}
\item \texttt{canBeAvailable}
\item \texttt{finalise1}
\item \texttt{finalise2}
\item \texttt{codeMotion}
\end{itemize}
\paragraph*{$\Phi$-insertion}
A $\Phi$ is needed whenever two different values of $E$ reach a common point in
the program. Therefore, there are two sets of vertices in whose iterated
dominance frontier we will insert $\Phi$-functions: the set $R$ of real
occurrences of $E$ and the set $A$ of vertices with assignments to an operand of
$E$. An assignment to an operand of $E$ is a computation of $E$ which produces
the value $\bot$. 

\textbf{Thus, we insert a $\Phi$ at the beginning of every vertex in
$DF^+(R) \cup DF^+(A)$}.

An \textbf{evaluation} of a computation $E$ is either a real occurrence, a
$\Phi$ occurrence or an assignment to an operand of $E$.

\paragraph*{Renaming}
Two occurrences of $E$ with the same version number have equal values. 
The algorithm is based on the rename algorithm for the translation to SSA form.
There are stacks for versions of the variables and stacks for versions of each
computation.

\negv
\begin{program}
|pre-order traversal of the dominator tree|
|when an occurrence | o | of | E | is encountered: |
\IF (o | is a |\Phi| occurrence| ) \AR*
    |a new version is created|
    \textbf{return}
\FI
|compare the occurrence on top of the stack of | E
|with the top of the stack of each operand in the computation |
\IF (o | is a real occurrence | \land |all the versions match|) \AR*
    |add an upward edge in the factored redundancy graph|
    |from the occurrence to the top of the computation stack|
\ELSIF (o | is a real occurrence | \land |some version doesn't match|) \AR*
    |a new version is assigned to the occurrence|
\ELSE %! FIX INDENTATION
    \texttt{// the occurrence is a $\Phi$ operand}
    |assign the occurrence the special version |\bot
\FI
\end{program}

\paragraph*{Computing downsafety}
To insert a computation $E$ at point $p$ it is required that $E$ is anticipated
at $p$. We may want to insert computations only at $\Phi$ operands that are 
$\bot$. With no critical edges, if a computation is anticipated at a $\Phi$ it
is also anticipated on each of its $\Phi$-operands. A $\Phi$ is not downsafe if
there is a path from that $\Phi$ along which there is no real occurrence of the
computation before program exit or before the computation's value has been
altered. This algorithm checks the latter case, the first can be discovered
during renaming if a $\Phi$ is on the top of a stack when the exit vertex is
reached.

\pagebreak
\begin{program}
\PROC |downsafety| \BODY
    \FOREACH |f in | FGT \DO
        \IF (!|downsafe|[f]) \AR*
            \FOREACH |operand | \omega | of | f \DO
                |resetDownsafe|(\omega)
            \OD
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |resetDownsafe|(|operand | \omega) \BODY
    \IF (|hasRealUse|[\omega] \lor |def|(\omega) | is not a | \Phi) \AR*
        \textbf{return}
    \FI
    f = |def|[\omega]
    \IF (!|downsafe|[f]) \AR* \textbf{return} \FI
    |downsafe|[f] = false
    \FOREACH |operand o | of f \DO
        |resetDownsafe|(o)
    \OD
\end{program}

\paragraph*{Availability}
For some of the $\Phi$s with a $\bot$ operand we insert the computation for each
of those $\bot$ operands. We cannot insert a computation for any $\Phi$ with a
$\bot$ operand, but only for the $\Phi$s which are downsafe. \textbf{The 
availability step finds the $\Phi$s where an expression can be safely made
available and then finds the latest points to insert new computations in
order to reduce the size of live ranges}.

\texttt{canBeAvailable} searches the FRG from the $\Phi$s which are not downsafe
and which have at least one $\bot$ operand. The \texttt{canBeAvailable}
predicate is set to false for such $\Phi$s and the false value is propagated
forward.

Then, \texttt{computeLater} initialises the \texttt{later} predicate to the
value of \\ \texttt{canBeAvailable}. The meaning of \texttt{later} is that if it is
true for a $\Phi$, then we do not have to insert a new computation in that
$\Phi$; we can insert the computation later. The \texttt{later} predicate is set
to false for the $\Phi$ with an operand which has a real use. Postponing the
insertion of the expression to after that real use will introduce redundancy,
since on the path from the real use to the newly inserted computation, the
computation is evaluated more than once.

The \texttt{computeLater} then searches the FRG as shown in Algorithm 5.4
Whether an expression will be available at a $\Phi$ is now given by:
\begin{verbatim}
willBeAvailable = canBeAvailable && !later
\end{verbatim}
Each $\Phi$ operand has a predicate \texttt{insert}, which determines whether a
computation should be inserted at that operand, and it is true \iff the $\Phi$
satisfies \texttt{willBeAVailable} and the operand is $\bot$ or defined by a
$\Phi$ which does not satisfy \texttt{willBeAvailable}.

\begin{program}
\PROC |computeWillBeAvailable|() \BODY
    |computeCanBeAvailable|
    |computeLater|
    \texttt{//willBeAvailable is canBeAvailable and NOT later}
\end{program}
\negv
\begin{program}
\PROC |computeCanBeAvailable|() \BODY
    \FOREACH |f in | FGT \DO
        |canBeAvailable|[f] = true
    \OD
    \FOREACH |f in | FGT \DO
        \IF (!|downsafe|[f] \land |canBeAvailable|[f] \land | there is an operand of | f | that is | \bot) \AR*
            |resetCanBeAvailable|(f)
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |resetCanBeAvailable|(f) \BODY
    |canBeAvailable|[f] = false
    \FOREACH |g in | FGT | with operand | \omega | such that | f = |def|(\omega) \DO
        \IF (!|hasRealUse|(\omega) \ \land \ !|downsafe|[g] \land | canBeAvailable|[g]) \AR*
            |resetCanBeAvailable|(g)
    \OD
\end{program}
\negv
\begin{program}
\PROC |computeLater|() \BODY
    \FOREACH |f in | FGT \DO
        |later|[f] = |canBeAvailable|[f]
    \OD
    \FOREACH |f in | FGT \DO
        \IF (|later|[f] \land | an operand | \omega | of | f | satisfies hasRealUse|[\omega] | and def|[\omega] \not= \bot) \AR*
            |resetLater|(f)
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |resetLater|(f) \BODY
    |later|[f] = false
    \FOREACH |g in | FGT | with operand | \omega | such that | f = |def|(\omega) \DO
        \IF (|later|[g]) \AR*
            |resetLater|(g)
    \OD
\end{program}

\paragraph*{Finalise}
It performs insertions and deletions of real occurrences and the saving and
reloading of the temporary $t$ associated with the expression.

These are the tasks for \texttt{finalise1}:
\begin{itemize}
\item To set a flag called \texttt{reload} for each real occurrence, which
specifies whether the occurrence should fetch the value by reading a temporary
$t_k$ (with $k$ denoting $t$'s SSA version) or it should perform the computation
itself.
\item For $\Phi$s which satisfy \texttt{willBeAvailable}, the expression is
inserted at incoming edges where the expression is not available
\item Determining which $\Phi$s will become $\phi$s for $t$
\item Updating the FRG so that $t$ becomes a variable in SSA form
\end{itemize}
\texttt{finalise1} makes a preorder traversal of the DT to find which definition
of $t_k$ should be used by the real occurrence whose \texttt{reload} flag is
true. In contrast with SSA renaming, \texttt{finalise1} does not need rename
stacks. Instead, a table called \texttt{availableDef} of available definitions
is used for the three first tasks of \texttt{finalise1}. \texttt{availableDef}
is indexed by redundancy class numbers, and \texttt{availableDef[x]} points to
the occurrence that defines the value of occurrences in redundancy class $x$
when a reload of class $x$ is seen. This defining occurrence is either a real
occurrence or a $\Phi$ which satisfies \texttt{willBeAvailable}.

\begin{program}
\PROC finalise1() \BODY
    E = | the current expression|
    \FOREACH | redundancy class | x | of | E \DO
        |availableDef|[x] = \bot
    \OD
    \FOREACH | occurrence | \psi | of | E | in a preorder DT traversal | \DO
        x = |class|(\psi)
        \IF (\psi | is a | \Phi | occurrence|) \AR*
            \IF (|willBeAvailable|[\psi]) \AR*
            |availableDef|[x] = \psi
            \FI
        \ELSIF (\psi | is a real occurrence|) \AR*
            \IF (|availableDef|[x] = \bot \lor |availableDef|[x] | does not dominate | \psi) \AR*
                |reload|[\psi] = false
                |availableDef|[x] = \psi
            \ELSE
                |reload|[\psi] = true
                |def|[\psi] = |availableDef|[x]
            \FI
        \ELSE \texttt{  // $\psi$ is a $\Phi$ operand occurrence}
            f = | the | \Phi | in the successor vertex of this operand |
            \IF (|willBeAvailable|[f]) \AR*
                \IF (\psi | satisfies insert|) \AR*
                    |insert | E | at the end of the vertex containing | \psi
                    |def|[\psi] = |inserted occurrence|
                \ELSE
                    |def|[\psi] = |availableDef|[x]
                \FI
            \FI
        \FI
    \OD
\end{program}
Initially, all entries of \texttt{availableDef} are $\bot$ and during the
preorder traversal they will be updated as follows. $x$ is the redundancy class
number of the occurrence we visit.
\begin{itemize}
\item We visit a $\Phi$. If the $\Phi$ satisfies \texttt{willBeAvailable}, we
visit the redundancy class $x$ of this $\Phi$ for the first time and therefore
set \texttt{availableDef[x] = $\Phi$}. If the $\Phi$ does not satisfy
\texttt{willBeAvailable}, this $\Phi$ will not be part of the SSA graph for $t$
and we do nothing.
\item We visit a real occurrence $r$. If \texttt{availableDef[x] = $\bot$} or
\texttt{availableDef[x]} does not dominate this occurrence (which can happen,
for instance, if \texttt{availableDef[x]} was set at a then-clause and
we are processing a vertex in the else-clause), \textbf{then} we set
\texttt{availableDef[x] = $\Phi$}. If \texttt{availableDef[x] $\not= \bot$} and
\texttt{availableDef[x]} dominates this occurrence then we record
\texttt{availableDef[x]} as the defining occurrence of \texttt{r}: \texttt{def[r] =
    availableDef[x]} and set the \texttt{reload} flag to true.
\item We visit a $\Phi$ operand $\omega$. If $\omega$'s $\Phi$ is not
\texttt{willBeAvailable}, then nothing is done. Otherwise, if $\omega$ satisfies
insert we insert a new real occurrence \texttt{occ} at $\omega$ and set
\texttt{def[$\omega$] = occ}, and if $\omega$ does not satisfy insert we set
\texttt{def[$\omega$] = availableDef[x]}.
\end{itemize}

These are the tasks for \texttt{finalise2}:
\begin{itemize}
\item To set a flag called \texttt{save} for real occurrences which should save
their computation to $t$ for use by subsequent reloads by other real
occurrences
\item Remove extraneous $\Phi$s
\end{itemize}

\pagebreak
\begin{program}
\PROC |finalise2|() \BODY
    \FOREACH f | in FRG satisfying willBeAvailable | \DO
        |extraneous|[f] = true
    \OD
    \FOREACH | real occurrence | \psi \DO
        |save|[\psi] = false
    \OD
    \FOREACH f | in FGR | \DO
        \FOREACH | operand | \omega | of | f \DO
            |processed|[\omega] = false
        \OD
    \OD
    \FOREACH | real occurrence | \psi | satisfying reload| \DO
        |setSave|(|def|(\psi))
    \FOREACH F | in FGR | \DO
        \IF (f | satisfies willBeAvailable|) \AR*
            \IF (|extraneous|[f]) \AR*
                \FOREACH | operand | \omega | of | f \DO
                    \IF (|def|[\omega] | is a | \Phi | and not extraneous|[|def|[\omega]]
                         \lor | def|[\omega] | is real | \lor
                         \lor | def|[\omega] | is inserted|) \AR*
                        |setReplacement|(f, |def|[\omega])
                    \ELSE
                        F = F - \{f\}
                    \FI
                \OD
            \FI
        \FI
    \OD
\end{program}

\begin{program}
\PROC |setSave|(\psi) \BODY
    \IF (\psi | is a real occurrence|) \AR*
        |save|(\psi) = true
    \ELSIF (\psi | is a | \Phi | occurrence|) \AR*
        \FOREACH |operand | \omega | of | \psi \DO
            \IF (!|processed|[\omega]) \AR*
                |setSave|(|def|[w])
            \FI
        \OD
    \FI
    \IF (\psi | is real or inserted occurrence|) \AR*
        \FOREACH (|willBeAvailable | f | in FRG such that | f \in DF^+(\psi)) \DO
            |extraneous|[f] = false
        \OD
    \FI
\end{program}
\pagebreak
\begin{program}
\PROC |setReplacement|(g, |replacingDefinition|) \BODY
    \FOREACH |willBeAvailable | f | in FGR with j-th operand defined by | g \DO
        \IF (|extraneous|[f]) \AR*
            |setReplacement|(|f|, |replacingDefinition|)
        \ELSE
            |replace j-th operand by replacingDefinition|
        \FI
        \FOREACH |real occurrence | \psi | satisfying reload with def|[\psi] = g \DO
            F = F - \{g\}
        \OD
    \OD
\end{program}

\paragraph*{Code motion}
The last part of SSAPRE updates the program with the temporary expressions on
SSA form. In a preorder traversal of the dominator tree, each occurrence is
processed as follows: if \texttt{save} is true, a new version of the temporary
is created and code is inserted to save the value of the expression in the
temporary. If the occurrence $\omega$ is a real or a $\Phi$ operand and the
reload flag is true, the computation is replaced by the use of the temporary
saved by \texttt{def($\omega$)}. At each inserted occurrence, the value is saved
in a new version of the temporary, and at a $\Phi$ a $\phi$-function for the
temporary is created.

\subsubsection*{Global Value Numbering (GNV)}
It aims at removing redundant computations. PRE discovers redundant evaluations
of some expression with particular lexical operator and operands, while GNV can
eliminate redundancy between lexically different expressions that produce the
same value.
\begin{verbatim}
x = a + a;
y = a * 2; // redundant
\end{verbatim}
It does not optimise partial redundancy.
Trend: use GNV, then PRE.

\paragraph*{Hash-based value numbering: a simpler version}
This is an improvement to the renaming stage of the translation to SSA form.

\pagebreak
\begin{program}
\PROC |search|(|vertex | v) \BODY
    |oldLHS| = |new List|
    |enter new scope in hash table | (|hashTable|[v])
    \FOREACH | statement | s | in | v \DO
        \FOREACH | variable | x | in | RHS(s) \DO
            i = |S|[x].|top|()
            |replace use of | x | by use of | x_i
        \OD
        x = |LHS|(s)
        \IF (x = null) \AR*
            \textbf{continue}
        \FI
        |oldLHS|.|add|(x)
        |simplify | s | using e.g. | x_i - x_i = 0
        h = |hashTable|[v][|RHS|(s)]
        \IF (h | was found|) \AR*
            |push (left-hand side) | h | onto S|[x]
        \ELSE
            i = |C|[x]
            |replace | x | by | x_i
            |S|[x].|push|(i)
            |C|[x] \texttt{ += } 1
            |hashTable|[v][|RHS|(s)] = |LHS|(s)
        \FI
    \OD
    \FOREACH w | in | succ(v) \DO
        j = |which predecessor is v to w? | \hspace{1cm} \texttt{// first, second, ... ?}
        \FOREACH \Phi|-function in | w \DO
            i = |S|[x].|top|()
            |replace use of the | j |-th operand in | RHS(\Phi) | by use of | x_i
        \OD
    \OD
    \FOREACH w | in children|(v) \DO
        |search|(w)
    \texttt{// pop every variable version pushed in v}
    \FOREACH | variable | x | in | oldLHS(s) \DO
        |S|[x].|pop|()
    \OD

\end{program}

%Hashbased value number
%Global value numbering
%Ssa pre (partial redundancy elimination)
\end{document}

