\documentclass[a4paper,12pt, notitlepage]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{program}
\usepackage{color}

\renewcommand{\o}{\lor}
\newcommand{\gge}{\ \underline{\gg}\ }
\newcommand{\lle}{\ \underline{\ll}\ }
\newcommand{\no}{\neg}
\newcommand{\eq}{\equiv}
\newcommand{\nq}{\not\equiv}
\newcommand{\tq}{\mid}
%\newcommand{\impl}{\Rightarrow}
\newcommand{\conseq}{\Leftarrow}
\newcommand{\existe}[3]{(\exists #1 \mid #2 : #3)}
\newcommand{\patodo}[3]{(\forall #1 \mid #2 : #3)}
\newcommand{\cgen}[4]{(#1 #2 \mid \ #3 : #4)}
\newcommand{\sust}[3]{#1 [#2 := #3]}
\newcommand{\nolibre}[2]{\no \textit{ocurre-libre}('#1', '#2')}
\newcommand{\range}[3]{#1 \leq #2 < #3}

\renewcommand{\iff}{\textbf{ iff }}

\newcommand{\ind}[1]{\hspace*{#1 cm}}
\newcommand{\negv}{\vspace{-0.7cm}}

\begin{document}

\begin{center}

{\Large{Study Guide\\ \bigskip
			Optimising Compilers @ Lunds Universitet}}
\vspace{1cm}
\end{center}
\section*{Basics}
\subsubsection*{Lattice}
It's a partially ordered set where every pair has least upper and greatest lower
bounds (supremum and infimum) which are unique. They are called the
\textit{join} ($\lor$) and \textit{meet} ($\land$), respectively.

\subsubsection*{Tarjan's algorithm for Strongly Connected Components}
\negv
\begin{program}
\PROC |tarjan|() \BODY
    |components| = |new Set|
    |dfsNumIndex| = 0
    |stack| = |new Stack|
    \FOREACH |vertex | v | in | V \DO
        \IF (|dfsNum|[v] = null) \AR*
            strongConnect(v)
        \FI \OD
\end{program} \negv
\begin{program}
\PROC |strongConnect|(|vertex | v) \BODY
    |dfsNum|[v] = |dfsNumIndex|
    |lowLink|[v] = |dfsNumIndex|
    |dfsNumIndex| \texttt{ += } 1
    |stack|.|push|(v)
    \FOREACH w | in | succ(v) \DO
        \IF (|dfsNum|[w] = null) \AR*
            |strongConnect|(w)
            |lowLink|[v] = min(|lowLink|[v], |lowLink|[w])
        \ELSIF (|dfsNum|[w] < |dfsNum|[v] \land |stack|.|contains|(w)) \AR*
            |lowLink|[v] = min(|lowLink|[v], |dfsNum|[w]) \FI
    \OD
    \IF (|lowLink|[v] = |dfsNum|[v]) \AR*
        |scc| = |new Set|
        \DOW
            w = |stack|.|pop|()
            |scc|.|add|(w)
        \ODW (w \not= v)
        |components|.|add|(|scc|)
    \FI
\end{program}

\section*{Dominance Analysis}
\subsubsection*{Compute dominance}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gge w $ \iff every path from $s$ to $w$ includes $v$. 
\\ $v$ \textbf{dominates} $w$.
\item $dom(w) = \{v \mid v \gge w\}$
\item $\gge$ is a partial order relation. 
\item $u \gge v$ \iff $u \gge p_i$ for every $p_i \in pred(v)$
\item $dom(w) = \{w\} \cup \displaystyle \bigcap_{p \in pred(w)} dom(p)$
\end{enumerate}
\vspace{-0.5cm}
\paragraph*{Algorithm}
\begin{program}
\PROC |computeDominance|() \BODY
    |dom|[s] = \{s\}
    \FOREACH |vertex | v | in | V | except | s \DO
        |dom|[v] = V \OD
    \WHILE |some dom|[v] | has changed| \DO
        \FOREACH |vertex | v | in | V | except | s \DO
            |dom|[v] = \{v\} \cup \displaystyle \bigcap_{p \in pred(v)} |dom|[p]
            \OD
    \OD
\end{program}
\subsubsection*{Lenguaer-Tarjan Algorithm (Dominator Tree)}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gg w $ \iff $v \gge w \land v \not= w$
\\ $v$ \textbf{strictly dominates} $w$.
\item $v \in dom(w) \land u \in dom(w) \Rightarrow u \gge v \lor v \gge u$
\item $v = iDom(w)$ \iff $v \gg w \land \patodo{u}{u \gg w}{v \not\gg u}$
\\ $v$ \textbf{is the immediate dominator of} $w$.
\item The graph of the reflexive and transitive closure of the dominance
relation is a  tree, called the dominator tree (DT). $(u,v) \in DT$ 
\iff $u = iDom(v)$.
\item $u \gge v$ \iff $dfsNum(u) \leq dfsNum(v) \land \\ 
dfsNum(v) \leq dfsNum(u) + numberOfDescendants(u)$
\item $v = sDom(w)$ \iff $v$ is the smallest vertex by $dfsNum$ such that there
is a path $(v, u_1, u_2, ..., u_{k-1}, w)$ with $dfsNum(u_i) > dfsNum(w)$.
\\ The semidominator is frequently equal to the immediate dominator.
\end{enumerate}

\paragraph*{Algorithm}
$parent$ is the parent in the DFS tree after calling $dfs()$.
\begin{program}
\PROC |lenguaerTarjan|() \BODY
    |emptyBuckets()|
    |setSdominatorsToSelf()|
    |dfs()|
    \FOREACH |vertex | v | in reverse | dfsNumber | order| \DO
        \FOREACH |predecessor | p | of | v \DO
            u = |ancestorWithLeastSdom(p)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[v])) \AR*
                |sDom|[v] = |sDom|[u] 
            \FI
        \OD
        |bucket|[|sDom|[v]].add(v)
        |ancestor|[v] = |parent|(v) 
        \FOREACH |vertex | b| in bucket|[|parent|(v)] \DO
            |remove b|
            u = |ancestorWithLeastSdom(b)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[b])) \AR*
                |iDom|[b] = u
            \ELSE
                |iDom|[b] = |parent|(v)
            \FI
        \OD
    \OD
    \FOREACH |vertex | v | except | s \DO
        \IF |iDom|[v] \not= |sDom|[v] \AR*
            |iDom|[v] = |iDom|[|iDom|[v]]
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |ancestorWithLeastSdom|(|vertex |w) \BODY
    |go through the ancestor chain of | w
    |return ancestor with the least sDom|
\end{program}

\section*{Loop Analysis}
\subsubsection*{Basics}
\begin{enumerate}
\item A loop is a subgraph of the CFG that is a strongly connected component
\item An entry loop is a vertex with a predecessor that is not in the loop
\item Irreducible loops have multiple entry points
\item Reducible or natural loops only have one entry point: the loop header. 
It dominates all other vertices in the loop.
\end{enumerate}
\begin{tabular}{ll}
forward arc & $u < v$\\
back arc & $u > v \ \land $ v is left in the stack\\
\end{tabular}
\negv
\begin{program}
\PROC |identifyNaturalLoops|() \BODY
    \FOREACH |back edge | (v, w) | of | G \DO
        \IF (w.|dominates|(v)) \AR*
            |search backwards all paths from | v | to | w.
            |the visited vertices belong to the natural loop|
        \FI
    \OD
\end{program}

\section*{Dataflow Analysis}
\subsubsection*{Basics}
\begin{itemize}
\item It is concerned with how a procedure uses and defines its variables and 
expressions
\item Every assignment statement is given an index
\item Local analysis discovers what happens within a vertex: its output is
$gen(v)$ and $kill(v)$
\item Global analysis: each vertex has $in(v)$ and $out(v)$ in addition to $gen$
and $kill$.
\end{itemize}
\begin{tabular}{ll}
$in(v)$ & definitions reaching the beginning of $v$ \\
$out(v)$ & definitions reaching the end of $v$ \\
$gen(v)$ & definitions generated in $v$ \\
$kill(v)$ & definitions killed in $v$ \\
\end{tabular}

\begin{program}
\PROC |reachingDefs|() \BODY
    |workList| = |vertices in reverse postorder|
    \WHILE |workList is not empty| \DO
        v = |workList|.|first|()
        |old| = |out|[v]
        |in|[v] = \displaystyle \bigcup_{p \in pred(v)} |out|[p]
        |out|[v] = |gen|[v] \cup (|in|[v] - |kill|[v])
        \IF (|old| \not= |out|(v)) \AR*
            \FOREACH |succesor | s | of | v \DO
                \IF (s | is not in workList|) \AR* 
                    |workList|.|add|(s)
                \FI
            \OD
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |localLiveAnalysis|() \BODY
    \FOREACH |vertex | v \DO
        \FOREACH |statement | s \DO
            \FOREACH |used variable | x | of | s \DO
                \IF (x \not\in |kill|[v]) \AR*
                   |use|[v].|add|(x)
                \FI
            \OD
            \FOREACH |defined variable | x | of | s \DO
                \IF (x \not\in |gen|[v]) \AR*
                   |kill|[v].|add|(x)
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |globalLiveAnalysis|() \BODY
    \WHILE |some in|[v] | has changed| \DO
        \FOREACH |vertex v | \DO
            |out|[v] = \displaystyle \bigcup_{s \in succ(v)} |in|[s]
            |in|[v] = |use|[v] \cup (|out|[v] - |kill|[v])
        \OD
    \OD
\end{program}

\section*{Static Single Assignment Form}
\begin{itemize}
\item Every variable is defined as most once (statically)
\item $\phi$-functions: one argument for each predecessor at some join vertices
\end{itemize}

\subsubsection*{Dominance Frontiers}
\paragraph*{Theory}
\begin{enumerate}
\item $DF(v) = \{w \mid \existe{p}{p \in pred(w)}{v \gge p \land v \not\gg w}\}$
\\ the \textbf{dominance frontier of vertex v}
\\ the set of vertices $w$ such that $v$ dominates a predecessor of $w$, but does
not strictly dominate $w$.
\\ if $v$ dominates a predecessor of $w$ but does not strictly dominate $w$,
    then $w$ is in the dominance frontier of $v$.
\item $DF_{local}(v) = \{w \in succ(v) \mid v \not\gg w\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(v) \not\gg w\}$
\item $DF(v) = DF_{local}(v) \cup 
    \displaystyle \bigcup_{w \in children(v)} DF_{up}(w)$
\item $DF_{local}(v) = \{w \in succ(v) \mid iDom(w) \not= v\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(w) \not= v\}$
\end{enumerate}

\paragraph*{Algorithm}
\begin{program}
\PROC |dominanceFrontiers|() \BODY
    \FOREACH | vertex | v | in a postorder traversal of DT | \DO
        |dominanceFrontier|[v] = |new Set|
        \FOREACH | vertex | w | in succ|(v) \DO
            \IF (|iDom|(w) \not= v) \AR*
                |dominanceFrontier|[v].|add|(w)
            \FI
        \OD
        \FOREACH | vertex | w | in children|(v) \DO
            \FOREACH | vertex | u | in dominanceFrontier|[w] \DO
                \IF (iDom(u) \not= v) \AR*
                    |dominanceFrontier|[v].|add|(u)
                \FI
            \OD
        \OD
    \OD
\end{program}

\subsubsection*{Insertion of $\phi$-functions}
\paragraph*{Theory}
\begin{enumerate}
\item Two paths $p = (v_0, ..., v_X)$ and $q = (w_0, ..., w_Y)$
\textbf{converge} at $u$ \iff
    \begin{enumerate}
        \item $v_0 \not= w_0$
        \item $v_X = w_Y = u$
        \item $(u_i = v_j) \Rightarrow i = X \lor j = Y$
    \end{enumerate}
\item Given a set $A$ of vertices, the join of $A$ ($J(A)$) is the set of all
vertices $w$ such that there are two distinct vertices $u$ and $v$ in $A$ with
paths which converge at $w$.
\item $J_{i+1}(A) = J(A \cup J_{i}(A))$, $J^+(A)$ is the fixed-point.
\item $DF$ can be applied to sets of vertices, mapping $DF$ over all the
vertices of its argument.
\item $DF_{i+1}(A) = DF(A \cup DF_{i}(A))$, and $DF^+(A) = J^+(A)$.
\item The set of vertices which need $\phi$-functions for any variable $v$
is the iterated dominance frontier $DF_+(A)$, where $A$ is the set of vertices
with assignment statements to $v$.
\end{enumerate}

\pagebreak
\paragraph*{Algorithm}
\begin{program}
\PROC |insert_|\phi() \BODY
    |iteration| = 0
    \FOREACH | vertex | v \DO
        |hasAlready|[v] = 0
        |work|[v] = 0
    \OD
    W = |new Set|
    \FOREACH | variable | x \DO
        |iteration| \texttt{ += } 1
        \FOREACH | vertex | v \in A(x) \DO
            |work|[v] = |iteration|
            W.|add|(v)
        \OD
        \WHILE (W | is not empty|) \DO 
            v = |take vertex from | W
            \FOREACH w | in | DF(v) \DO
                \IF (|hasAlready|[w] < |iteration|) \AR*
                    |place | x = \phi(x,...,x) | at | w
                    |hasAlready|[w] = |iteration|
                    \IF (|work|[w] < |iteration|) \AR*
                        |work|[w] = |iteration|
                        W.|add|(w)
                    \FI
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |renameVariables|() \BODY
    \FOREACH | variable | x \DO
        |C|[x] = 0
        |S|[x] = |new Stack|
    \OD
    |search|(s) \hspace{1cm} \texttt{// s = the start vertex}
\end{program}
\pagebreak
\begin{program}
\PROC |search|(|vertex | v) \BODY
    |oldLHS| = |new List|
    \FOREACH | assignment statement | s | in | v \DO
        \FOREACH | variable | x | in | RHS(s) \DO
            i = |S|[x].|top|()
            |replace use of | x | by use of | x_i
        \OD
        \FOREACH | variable | x | in | LHS(s) \DO
            |oldLHS|.|add|(x)
            i = |C|[x]
            |replace | x | by | x_i
            |S|[x].|push|(i)
            |C|[x] \texttt{ += } 1
        \OD
    \OD
    \FOREACH w | in | succ(v) \DO
        j = |which predecessor is v to w? | \hspace{1cm} \texttt{// first, second, ... ?}
        \FOREACH \phi|-function in | w \DO
            i = |S|[x].|top|()
            |replace use of the | j |-th operand in | RHS(\phi) | by use of | x_i
        \OD
    \OD
    \FOREACH w | in children|(v) \DO
        |search|(w)
    \texttt{// pop every variable version pushed in v}
    \FOREACH | variable | x | in | oldLHS(s) \DO
        |S|[x].|pop|()
    \OD
\end{program}
\section*{SSA Optimisation}
\subsubsection*{Copy propagation}
\begin{verbatim}
int x;
int t;
t = a + b;
x = t;
\end{verbatim} \vspace{-0.3cm}
is translated into... \vspace{-0.3cm}
\begin{verbatim}
int t;
t = a + b;
\end{verbatim}

\begin{itemize}
\item It considers all copy statements such as \texttt{x = t} in a procedure and
propagates the source by replacing uses of the destination by uses of the source
instead.
\item If the destination is no longer used anywhere, it can be removed.
\item When SSA form is not used, copy propagation cannot be performed without
limitations: careful about redefinitions. One can use iterative dataflow
analysis.
\item Consider \texttt{x = t} and an expression \texttt{x + y} to which we want
to propagate \texttt{t}. On SSA form, it is always legal to propagate \texttt{t}
by replacing uses of \texttt{x} with uses of \texttt{t}. Recall that \textbf{at
any use of a variable, there is exactly one reaching definition of such a
variable and the definition of the variable dominates its use}.
\item Copy propagation can be performed during variable renaming: when the
statement is a copy statement \texttt{x = t}, the original renaming algorithm
replaces \texttt{t} with the top of the stack of \texttt{t}, say \texttt{t'},
and then replaces \texttt{x} with a new version of \texttt{x} which is
pushed on stack \texttt{x}. The new copy statement becomes \texttt{x' =
t'}. To do copy propagation during renaming, we simply push
\texttt{t'} on the stack of \texttt{x} and delete the copy
statement.
\end{itemize}
\begin{program}
\PROC |copy|() \BODY
    \FOREACH | variable | x \DO
        \IF (|def|[x] | is move | \land | source|[|def|[x]] | is var|) \AR*
            y = |source|(|def|(x))
            \FOREACH | use | u | of | x \DO
                |replace | x | by | y
                |add | u | to uses|[y]
            \OD
            |remove def|[x] | from the program|
            |remove | x | from the program|
\end{program}

\subsubsection*{Copy propagation}
\begin{itemize}
\item Simplifies expressions with compile-time constant operands. It can change
conditional branches to unconditional and delete code.
\item Initially only the start vertex is known to be executable.
\item CFG arcs on a worklist: it contains arcs which have been discovered to
possibly be eecutable.
\item At $\phi$-functions, only values from operands corresponding to CFG arcs
marked as executable are inspected. $\phi$-functions can become constant.
\item A lattice is used with three element types, $\top$, $\bot$ and $c_i$.
\item Initially, each lattice cell is $\top$, the unknown value.
If any of the source operands is $\bot$, the result becomes $\bot$, if both are
constants the result becomes constant. Otherwise, the result remains $\top$.
\item The first time a vertex is visited, all statements are interpreted.
Subsequent visits to the vertex only need to interpret the $\phi$-functions.
\end{itemize}

\negv
\begin{program}
\PROC |constantPropagation|() \BODY
    \FOREACH |definition | d \DO
        |value|[d] = \top
    \OD
    \FOREACH |vertex | v \DO
        |visited|[v] = false
    \OD
    |visitVertex|(s)
    \WHILE (|arcWorkList| \not= \emptyset \ \lor \ |ssaWorkList| \not= \emptyset) \DO
        \IF (|arcWorkList| \not= \emptyset) \AR*
            |arc| = |arkWorkList|.|first|()
            \IF (\neg |executable|[|arc|]) \AR*
                |executable|[|arc|] = true
                |visitVertex|(|head|(|arc|))
            \FI
        \FI
        \IF (|ssaWorkList| \not= \emptyset) \AR*
            t = |ssaWorkList|.|first|()
            |visitStatement|(t)
        \FI
    \OD
\end{program}

\negv
\begin{program}
\PROC |visitVertex|(v) \BODY
    |onlyPhi| = |visited|[v]
    |visited|[v] = true
    \FOREACH |statement | s | in | w \DO
        \IF (|onlyPhi | \land \ s | is not | \phi) \AR*
                \textbf{continue}
        \FI
        |visitStatement|(s, v)
    \OD
\end{program}

\pagebreak
\begin{program}
\PROC |visitStatement|(|vertex | v, | statement | s) \BODY
    |statementType| = |statementType|(s)
    \IF (|statementType is unconditional branch|) \AR*
        |arcWorkList|.|add|(v, |succ|(v))
    \ELSIF (|statementType is conditional branch|) \AR*
        |add appropriate arcs depending on what is known|
        |about the operands|
    \ELSIF (|statementType is add, mul, etc|) \AR*
        |left| = |value of the first source operand|
        |right| = |value of the second source operand|
        |result| = |what can be determined from left and right|
        \IF (|result| < |value|[s]) \AR*
            |add uses of destination of | s | to ssaWorkList|
            |value|[s] = |result|
        \FI
    \ELSIF (|statementType is a | \phi |-function|) \AR*
        |result| = \top
        \FOREACH p \in |pred|(v) \DO
            \IF (|executable|[(p,v)]) \AR*
                |value| = |value of | \phi|-function operand for | p
                |result| = |infimum|(|result|, |value|)
            \FI
        \OD
        \IF (|result| < |value|[s]) \AR*
            |add uses of destination of | s | to ssaWorkList|
            |value|[s] = |result|
        \FI
    \FI
    ...

\end{program}

\section*{Dead Code Elimination}
\subsubsection*{Control dependence}
\begin{itemize}
\item Removes useless statements: a statement is useless if it cannot affect
program output in any way
\item First remove unreachable code: DFS from the start vertex and delete all
unvisited vertices
\item Early DCE algorithms: live variable analysis to remove assignments to 
local variables which have no use
\item Other optimisations on SSA form frequently produce useless code
\item New idea: statements which can directly affect output are \texttt{prelive}
and are marked as \texttt{live}, then a search from their operands mark
additional statements as \texttt{live}. These statements are put in
\texttt{prelive}:
    \begin{enumerate}
    \item Writes to global variables and through pointers
    \item Function calls to I/O routines
    \item Function calls with unknown side-effects
    \item Return statements
    \end{enumerate}
\item When a statement is marked as \texttt{live}, all multiway branches which
directly control whether that statement will be executed should also be marked
as \texttt{live}.
\end{itemize}
\paragraph*{Theory}
\begin{enumerate}
\item The reverse control flow graph: s and e have switched roles.
\item Postdominance, $\lle$, is equivalent to dominance in the RCFG.
\item Control dependence is equivalent to dominance frontiers in the RCFG.
\item A vertex $v$ is control dependent on $w \in CD^{-1}(v)$ if $v$
postdominates a succesor of $w$ but does not strictly postdominate $w$:\\
$CD^{-1}(v) = \{w \mid \existe{s \in succ(w)}{}{v \lle s \ \land \ v \not\ll w}\}$
\item $w \in CD^{-1}(v) $ in the CFG \iff $w \in DF(v)$ in the RCFG
\end{enumerate}

\paragraph*{Algorithm}
\begin{program}
\PROC |computeControlDependence|() \BODY
    |build RCFG|
    |compute RDT|
    |compute RDF|
    \FOREACH | vertex | v \DO
        |CD|[u] = |new Set|
    \OD
    \FOREACH | vertex | v \DO
        \FOREACH | vertex | w | in RDF|(v) \DO
            |CD|[w].|add|(v)
        \OD
    \OD
\end{program}

\subsubsection*{Dead code elimination on SSA Form}
\texttt{eliminateDeadCode} will return a CFG that consists
of some vertices that are live and some that are not. Then, \texttt{simplify}
will connect the live blocks and delete the others.

\begin{program}
\PROC |eliminateDeadCode|() \BODY
    \FOREACH | statement | s \DO
        \IF (s | is prelive|) \AR*
            |live|[s] = true
            |workList|.|add|(s)
        \ELSE
            |live|[s] = false
        \FI
    \OD
    \WHILE (|workList| \not= \emptyset) \DO
        s = |workList|.|first|()
        v = |vertex|(s)
        |live|[v] = true
        \FOREACH | source operand | \omega | of | s \DO
            t = |def|(\omega)
            \IF (\neg |live|[t]) \AR*
                |live|[t] = true
                |workList|.|add|(t)
            \FI
        \OD
        \FOREACH | vertex | v \in |CD|^{-1}(|vertex|(s)) \DO
            t = |multiway branch of v|
            \IF (\neg |live|[t]) \AR*
                |live|[t] = true
                |workList|.|add|(t)
            \FI
        \OD
    \OD
    \FOREACH |statement | s \DO
        \IF (\neg|live|[s] \ \land \ |s is not a label | \land |s is not a branch|) \AR*
            |delete s|
        \FI
    \OD
    |simplify|()
\end{program}
\pagebreak
\begin{program}
\PROC |simplify|() \BODY
    |live|[e] = true
    |change| = false
    \FOREACH |vertex | v | in CFG| \DO
        \IF (\neg |live|[v]) \AR*
            \textbf{continue}
        \FI
        \FOREACH w \in |succ|(v) \DO
            \IF (|live|(w)) \AR*
                \textbf{continue}
            \FI
            u = iPdom(w) \texttt{// inmediate postdominator}
            |replace | (v, w) | with |(v, u)
            |update the branch in | v | to its new target | u
            |change| = true
        \OD
    \OD
    \IF (|change|) \AR*
        |delete vertices from CFG which have become unreachable|
        |update dominator tree|
    \FI
\end{program}

%%%%
\pagebreak
\section*{ADVANCED - SSA Optimisation}
\subsubsection*{Partial Redundancy Elimination (PRE)}
\paragraph*{Basics}
\begin{itemize}
\item Attempt to calculate expressions only once
\item Partial redundancy: one of the expressions is inside an \texttt{if-else}
\item Case examples
    \begin{enumerate}
        \item 
        \begin{verbatim}
if (a * b > max)
    max = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
if (t > max)
    max = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition)
    x = a * b
y = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    t = a * b
    x = t
}
else
    t = a * b
y = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \pagebreak
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition) {
    // some code
    y = x + 4
}
else {
    // other code
}
z = x + 4
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    // some code
    t = x + 4
    y = t
}
else {
    // other code
    t = x + 4
}
z = t
        \end{verbatim}
            
            

    \end{enumerate}
\item Loop improvement 
\item Global value numbering can optimise code that PRE cannot
\item Common subexpression elimination and code motion of loop invariants are
subsumed by PRE
\end{itemize}

%
%\paragraph*{Theory}
%\begin{enumerate}
%\item Two operands $a_j$ and $b_k$ are equal \iff $a = b$
%\item A computation $E_1$ at some point in the program is an occurrence of
%computation $E$ if both perform the same operation and have equal operands
%\item A computation $E$ is preserved along a path $P$ if $P$ contains nothing
%that may alter the value of $E$.
%\item If $E_1$ and $E_2$ are occurrences of $E$, and there is a path in the
%program from $E_1$ to $E_2$ which preserves $E$, then $E_2$ is said to be
%redundant with respect to $E_1$.
%\item If $p$ is a point in the program and there is a path from $p$ to $E_1$
%which preserves $E$ and contains no occurrence of $E$ between $p$ and $E_1$, 
%$E_1$ is exposed with respect to $p$.
%\item The set of occurrences to which $E_0$ is both redundant and exposed is
%denoted $\Omega$.
%\item The set of alterations of the value of $E$ is denoted $A$ (remember
%        translation to SSA-form).
%\item A vertex $v$ in $G$ is a $\Phi$-vertex for $E_0$ \iff
%    \begin{itemize}
%        \item The beginning of $v$ dominates $E_0$
%        \item There exist distinct $u_1$, $u_2 \in \Omega \cup A$ and paths $p_1$ 
%        and $p_2$ such that $u_1$ is contained in the first vertex of $p_1$, 
%        $u_2$ is contained in the first vertex of $p_2$, and $p_1$ and $p_2$
%        converge in $v$.
%    \end{itemize}
%\item An occurrence is \textbf{real} if it corresponds to code in the program,
%    $\Phi$ if it is a $\Phi$-function.
%\item A computation $E$ is partially available at point $p$ in the program if
%there is a path from a real occurrence of the computation to $p$ that preserves
%$E$.
%\item A computation $E$ is fully available at point $p$ in the program if it is
%partially available from every path from program entry $s$ to $p$.
%\item An occurrence $E_0$ is partially redundant if $E$ is partially available
%just before $E_0$
%\item An occurrence $E_0$ is fully redundant if $E$ is fully available
%just before $E_0$
%\item The factored redundancy graph (FRG) of a computation $E$ is a directed
%graph $FRG(N_{occ}, E_{up})$. The set of nodes consists of all real occurrences
%of $E$ plus a $\Phi$ node for each $\Phi$-vertex of a real occurrence of $E$.
%The edges in FRG are called upward edges and there is an upward edge in $E_{up}$
%from each partially redundant real occurrence and partially redundant $\Phi$
%operand occurrence to its representative occurrence.
%\item Analogous: partially and fully anticipated
%\item A placement is safe if all inserted real occurrences of a computation are
%fully anticipated or fully available
%\item A placement is computationally optimal if no safe placement can result in
%fewer occurrences of the computation along any path from entry to exit in the
%program
%\end{enumerate}
%
%\paragraph*{Algorithm} 
%\begin{itemize}
%\item \texttt{insert-$\Phi$}
%\item \texttt{rename}
%\item \texttt{downsafety}
%\item \texttt{canBeAvailable}
%\item \texttt{finalise1}
%\item \texttt{finalise2}
%\item \texttt{codeMotion}
%\end{itemize}
%\paragraph*{$\Phi$-insertion}
%A $\Phi$ is needed whenever two different values of $E$ reach a common point in
%the program. Therefore, there are two sets of vertices in whose iterated
%dominance frontier we will insert $\Phi$-functions: the set $R$ of real
%occurrences of $E$ and the set $A$ of vertices with assignments to an operand of
%$E$. An assignment to an operand of $E$ is a computation of $E$ which produces
%the value $\bot$. 
%
%\textbf{Thus, we insert a $\Phi$ at the beginning of every vertex in
%$DF^+(R) \cup DF^+(A)$}.
%
%An \textbf{evaluation} of a computation $E$ is either a real occurrence, a
%$\Phi$ occurrence or an assignment to an operand of $E$.
%
%\paragraph*{Renaming}
%Two occurrences of $E$ with the same version number have equal values. 
%The algorithm is based on the rename algorithm for the translation to SSA form.
%There are stacks for versions of the variables and stacks for versions of each
%computation.
%
%\negv
%\begin{program}
%|pre-order traversal of the dominator tree|
%|when an occurrence | o | of | E | is encountered: |
%\IF (o | is a |\Phi| occurrence| ) \AR*
%    |a new version is created|
%    \textbf{return}
%\FI
%|compare the occurrence on top of the stack of | E
%|with the top of the stack of each operand in the computation |
%\IF (o | is a real occurrence | \land |all the versions match|) \AR*
%    |add an upward edge in the factored redundancy graph|
%    |from the occurrence to the top of the computation stack|
%\ELSIF (o | is a real occurrence | \land |some version doesn't match|) \AR*
%    |a new version is assigned to the occurrence|
%\ELSE %! FIX INDENTATION
%    \texttt{// the occurrence is a $\Phi$ operand}
%    |assign the occurrence the special version |\bot
%\FI
%\end{program}
%
%\paragraph*{Computing downsafety}
%To insert a computation $E$ at point $p$ it is required that $E$ is anticipated
%at $p$. We may want to insert computations only at $\Phi$ operands that are 
%$\bot$. With no critical edges, if a computation is anticipated at a $\Phi$ it
%is also anticipated on each of its $\Phi$-operands. A $\Phi$ is not downsafe if
%there is a path from that $\Phi$ along which there is no real occurrence of the
%computation before program exit or before the computation's value has been
%altered. This algorithm checks the latter case, the first can be discovered
%during renaming if a $\Phi$ is on the top of a stack when the exit vertex is
%reached.
%
%\pagebreak
%\begin{program}
%\PROC |downsafety| \BODY
%    \FOREACH |f in | FGT \DO
%        \IF (!|downsafe|[f]) \AR*
%            \FOREACH |operand | \omega | of | f \DO
%                |resetDownsafe|(\omega)
%            \OD
%        \FI
%    \OD
%\end{program}
%\negv
%\begin{program}
%\PROC |resetDownsafe|(|operand | \omega) \BODY
%    \IF (|hasRealUse|[\omega] \lor |def|(\omega) | is not a | \Phi) \AR*
%        \textbf{return}
%    \FI
%    f = |def|[\omega]
%    \IF (!|downsafe|[f]) \AR* \textbf{return} \FI
%    |downsafe|[f] = false
%    \FOREACH |operand o | of f \DO
%        |resetDownsafe|(o)
%    \OD
%\end{program}
%
%\paragraph*{Availability}
%For some of the $\Phi$s with a $\bot$ operand we insert the computation for each
%of those $\bot$ operands. We cannot insert a computation for any $\Phi$ with a
%$\bot$ operand, but only for the $\Phi$s which are downsafe. \textbf{The 
%availability step finds the $\Phi$s where an expression can be safely made
%available and then finds the latest points to insert new computations in
%order to reduce the size of live ranges}.
%
%\texttt{canBeAvailable} searches the FRG from the $\Phi$s which are not downsafe
%and which have at least one $\bot$ operand. The \texttt{canBeAvailable}
%predicate is set to false for such $\Phi$s and the false value is propagated
%forward.
%
%Then, \texttt{computeLater} initialises the \texttt{later} predicate to the
%value of \\ \texttt{canBeAvailable}. The meaning of \texttt{later} is that if it is
%true for a $\Phi$, then we do not have to insert a new computation in that
%$\Phi$; we can insert the computation later. The \texttt{later} predicate is set
%to false for the $\Phi$ with an operand which has a real use. Postponing the
%insertion of the expression to after that real use will introduce redundancy,
%since on the path from the real use to the newly inserted computation, the
%computation is evaluated more than once.
%
%The \texttt{computeLater} then searches the FRG as shown in Algorithm 5.4
%Whether an expression will be available at a $\Phi$ is now given by:
%\begin{verbatim}
%willBeAvailable = canBeAvailable && !later
%\end{verbatim}
%Each $\Phi$ operand has a predicate \texttt{insert}, which determines whether a
%computation should be inserted at that operand, and it is true \iff the $\Phi$
%satisfies \texttt{willBeAVailable} and the operand is $\bot$ or defined by a
%$\Phi$ which does not satisfy \texttt{willBeAvailable}.
%
%\begin{program}
%\PROC |computeWillBeAvailable|() \BODY
%    |computeCanBeAvailable|
%    |computeLater|
%    \texttt{//willBeAvailable is canBeAvailable and NOT later}
%\end{program}
%\negv
%\begin{program}
%\PROC |computeCanBeAvailable|() \BODY
%    \FOREACH |f in | FGT \DO
%        |canBeAvailable|[f] = true
%    \OD
%    \FOREACH |f in | FGT \DO
%        \IF (!|downsafe|[f] \land |canBeAvailable|[f] \land | there is an operand of | f | that is | \bot) \AR*
%            |resetCanBeAvailable|(f)
%        \FI
%    \OD
%\end{program}
%\negv
%\begin{program}
%\PROC |resetCanBeAvailable|(f) \BODY
%    |canBeAvailable|[f] = false
%    \FOREACH |g in | FGT | with operand | \omega | such that | f = |def|(\omega) \DO
%        \IF (!|hasRealUse|(\omega) \ \land \ !|downsafe|[g] \land | canBeAvailable|[g]) \AR*
%            |resetCanBeAvailable|(g)
%    \OD
%\end{program}
%\negv
%\begin{program}
%\PROC |computeLater|() \BODY
%    \FOREACH |f in | FGT \DO
%        |later|[f] = |canBeAvailable|[f]
%    \OD
%    \FOREACH |f in | FGT \DO
%        \IF (|later|[f] \land | an operand | \omega | of | f | satisfies hasRealUse|[\omega] | and def|[\omega] \not= \bot) \AR*
%            |resetLater|(f)
%        \FI
%    \OD
%\end{program}
%\negv
%\begin{program}
%\PROC |resetLater|(f) \BODY
%    |later|[f] = false
%    \FOREACH |g in | FGT | with operand | \omega | such that | f = |def|(\omega) \DO
%        \IF (|later|[g]) \AR*
%            |resetLater|(g)
%    \OD
%\end{program}
%
%\paragraph*{Finalise}
%It performs insertions and deletions of real occurrences and the saving and
%reloading of the temporary $t$ associated with the expression.
%
%These are the tasks for \texttt{finalise1}:
%\begin{itemize}
%\item To set a flag called \texttt{reload} for each real occurrence, which
%specifies whether the occurrence should fetch the value by reading a temporary
%$t_k$ (with $k$ denoting $t$'s SSA version) or it should perform the computation
%itself.
%\item For $\Phi$s which satisfy \texttt{willBeAvailable}, the expression is
%inserted at incoming edges where the expression is not available
%\item Determining which $\Phi$s will become $\phi$s for $t$
%\item Updating the FRG so that $t$ becomes a variable in SSA form
%\end{itemize}
%\texttt{finalise1} makes a preorder traversal of the DT to find which definition
%of $t_k$ should be used by the real occurrence whose \texttt{reload} flag is
%true. In contrast with SSA renaming, \texttt{finalise1} does not need rename
%stacks. Instead, a table called \texttt{availableDef} of available definitions
%is used for the three first tasks of \texttt{finalise1}. \texttt{availableDef}
%is indexed by redundancy class numbers, and \texttt{availableDef[x]} points to
%the occurrence that defines the value of occurrences in redundancy class $x$
%when a reload of class $x$ is seen. This defining occurrence is either a real
%occurrence or a $\Phi$ which satisfies \texttt{willBeAvailable}.
%
%\begin{program}
%\PROC finalise1() \BODY
%    E = | the current expression|
%    \FOREACH | redundancy class | x | of | E \DO
%        |availableDef|[x] = \bot
%    \OD
%    \FOREACH | occurrence | \psi | of | E | in a preorder DT traversal | \DO
%        x = |class|(\psi)
%        \IF (\psi | is a | \Phi | occurrence|) \AR*
%            \IF (|willBeAvailable|[\psi]) \AR*
%            |availableDef|[x] = \psi
%            \FI
%        \ELSIF (\psi | is a real occurrence|) \AR*
%            \IF (|availableDef|[x] = \bot \lor |availableDef|[x] | does not dominate | \psi) \AR*
%                |reload|[\psi] = false
%                |availableDef|[x] = \psi
%            \ELSE
%                |reload|[\psi] = true
%                |def|[\psi] = |availableDef|[x]
%            \FI
%        \ELSE \texttt{  // $\psi$ is a $\Phi$ operand occurrence}
%            f = | the | \Phi | in the successor vertex of this operand |
%            \IF (|willBeAvailable|[f]) \AR*
%                \IF (\psi | satisfies insert|) \AR*
%                    |insert | E | at the end of the vertex containing | \psi
%                    |def|[\psi] = |inserted occurrence|
%                \ELSE
%                    |def|[\psi] = |availableDef|[x]
%                \FI
%            \FI
%        \FI
%    \OD
%\end{program}
%Initially, all entries of \texttt{availableDef} are $\bot$ and during the
%preorder traversal they will be updated as follows. $x$ is the redundancy class
%number of the occurrence we visit.
%\begin{itemize}
%\item We visit a $\Phi$. If the $\Phi$ satisfies \texttt{willBeAvailable}, we
%visit the redundancy class $x$ of this $\Phi$ for the first time and therefore
%set \texttt{availableDef[x] = $\Phi$}. If the $\Phi$ does not satisfy
%\texttt{willBeAvailable}, this $\Phi$ will not be part of the SSA graph for $t$
%and we do nothing.
%\item We visit a real occurrence $r$. If \texttt{availableDef[x] = $\bot$} or
%\texttt{availableDef[x]} does not dominate this occurrence (which can happen,
%for instance, if \texttt{availableDef[x]} was set at a then-clause and
%we are processing a vertex in the else-clause), \textbf{then} we set
%\texttt{availableDef[x] = $\Phi$}. If \texttt{availableDef[x] $\not= \bot$} and
%\texttt{availableDef[x]} dominates this occurrence then we record
%\texttt{availableDef[x]} as the defining occurrence of \texttt{r}: \texttt{def[r] =
%    availableDef[x]} and set the \texttt{reload} flag to true.
%\item We visit a $\Phi$ operand $\omega$. If $\omega$'s $\Phi$ is not
%\texttt{willBeAvailable}, then nothing is done. Otherwise, if $\omega$ satisfies
%insert we insert a new real occurrence \texttt{occ} at $\omega$ and set
%\texttt{def[$\omega$] = occ}, and if $\omega$ does not satisfy insert we set
%\texttt{def[$\omega$] = availableDef[x]}.
%\end{itemize}
%
%These are the tasks for \texttt{finalise2}:
%\begin{itemize}
%\item To set a flag called \texttt{save} for real occurrences which should save
%their computation to $t$ for use by subsequent reloads by other real
%occurrences
%\item Remove extraneous $\Phi$s
%\end{itemize}
%
%\pagebreak
%\begin{program}
%\PROC |finalise2|() \BODY
%    \FOREACH f | in FRG satisfying willBeAvailable | \DO
%        |extraneous|[f] = true
%    \OD
%    \FOREACH | real occurrence | \psi \DO
%        |save|[\psi] = false
%    \OD
%    \FOREACH f | in FRG | \DO
%        \FOREACH | operand | \omega | of | f \DO
%            |processed|[\omega] = false
%        \OD
%    \OD
%    \FOREACH | real occurrence | \psi | satisfying reload| \DO
%        |setSave|(|def|(\psi))
%    \FOREACH F | in FRG | \DO
%        \IF (f | satisfies willBeAvailable|) \AR*
%            \IF (|extraneous|[f]) \AR*
%                \FOREACH | operand | \omega | of | f \DO
%                    \IF (|def|[\omega] | is a | \Phi | and not extraneous|[|def|[\omega]]
%                         \lor | def|[\omega] | is real | \lor
%                         \lor | def|[\omega] | is inserted|) \AR*
%                        |setReplacement|(f, |def|[\omega])
%                    \ELSE
%                        F = F - \{f\}
%                    \FI
%                \OD
%            \FI
%        \FI
%    \OD
%\end{program}
%
%\begin{program}
%\PROC |setSave|(\psi) \BODY
%    \IF (\psi | is a real occurrence|) \AR*
%        |save|(\psi) = true
%    \ELSIF (\psi | is a | \Phi | occurrence|) \AR*
%        \FOREACH |operand | \omega | of | \psi \DO
%            \IF (!|processed|[\omega]) \AR*
%                |setSave|(|def|[w])
%            \FI
%        \OD
%    \FI
%    \IF (\psi | is real or inserted occurrence|) \AR*
%        \FOREACH (|willBeAvailable | f | in FRG such that | f \in DF^+(\psi)) \DO
%            |extraneous|[f] = false
%        \OD
%    \FI
%\end{program}
%\pagebreak
%\begin{program}
%\PROC |setReplacement|(g, |replacingDefinition|) \BODY
%    \FOREACH |willBeAvailable | f | in FRG with j-th operand defined by | g \DO
%        \IF (|extraneous|[f]) \AR*
%            |setReplacement|(|f|, |replacingDefinition|)
%        \ELSE
%            |replace j-th operand by replacingDefinition|
%        \FI
%        \FOREACH |real occurrence | \psi | satisfying reload with def|[\psi] = g \DO
%            F = F - \{g\}
%        \OD
%    \OD
%\end{program}
%
%\paragraph*{Code motion}
%The last part of SSAPRE updates the program with the temporary expressions on
%SSA form. In a preorder traversal of the dominator tree, each occurrence is
%processed as follows: if \texttt{save} is true, a new version of the temporary
%is created and code is inserted to save the value of the expression in the
%temporary. If the occurrence $\omega$ is a real or a $\Phi$ operand and the
%reload flag is true, the computation is replaced by the use of the temporary
%saved by \texttt{def($\omega$)}. At each inserted occurrence, the value is saved
%in a new version of the temporary, and at a $\Phi$ a $\phi$-function for the
%temporary is created.
%
%\subsubsection*{Global Value Numbering (GNV)}
%It aims at removing redundant computations. PRE discovers redundant evaluations
%of some expression with particular lexical operator and operands, while GNV can
%eliminate redundancy between lexically different expressions that produce the
%same value.
%\begin{verbatim}
%x = a + a;
%y = a * 2; // redundant
%\end{verbatim}
%It does not optimise partial redundancy.
%Trend: use GNV, then PRE.
%
%\paragraph*{Hash-based value numbering: a simpler version}
%This is an improvement to the renaming stage of the translation to SSA form.
%
%\pagebreak
%\begin{program}
%\PROC |search|(|vertex | v) \BODY
%    |oldLHS| = |new List|
%    |enter new scope in hash table | (|hashTable|[v])
%    \FOREACH | statement | s | in | v \DO
%        \FOREACH | variable | x | in | RHS(s) \DO
%            i = |S|[x].|top|()
%            |replace use of | x | by use of | x_i
%        \OD
%        x = |LHS|(s)
%        \IF (x = null) \AR*
%            \textbf{continue}
%        \FI
%        |oldLHS|.|add|(x)
%        |simplify | s | using e.g. | x_i - x_i = 0
%        h = |hashTable|[v][|RHS|(s)]
%        \IF (h | was found|) \AR*
%            |push (left-hand side) | h | onto S|[x]
%        \ELSE
%            i = |C|[x]
%            |replace | x | by | x_i
%            |S|[x].|push|(i)
%            |C|[x] \texttt{ += } 1
%            |hashTable|[v][|RHS|(s)] = |LHS|(s)
%        \FI
%    \OD
%    \FOREACH w | in | succ(v) \DO
%        j = |which predecessor is v to w? | \hspace{1cm} \texttt{// first, second, ... ?}
%        \FOREACH \Phi|-function in | w \DO
%            i = |S|[x].|top|()
%            |replace use of the | j |-th operand in | RHS(\Phi) | by use of | x_i
%        \OD
%    \OD
%    \FOREACH w | in children|(v) \DO
%        |search|(w)
%    \texttt{// pop every variable version pushed in v}
%    \FOREACH | variable | x | in | oldLHS(s) \DO
%        |S|[x].|pop|()
%    \OD
%\end{program}
%
%\paragraph*{Global value numbering}
%\begin{itemize}
%\item Constructs a value graph from the SSA graph. Nodes are values, labeled as
%variables, constants or operations. A $\phi$ function is labeled by its vertex
%in the CFG. There is an edge in the VG from a node which uses a value to the
%node that defines the value. The edges going from a node are ordered.
%\item Initially makes a partition $\pi_0$ where all nodes with the same function
%label are assumed to be congruent and belong to the same $B_i$. All 
%$\phi$-functions, multiplications and so on belong to different $B_i$s.
%\item We want a partition which gives us as many equal values as possible,
%satisfying the following rule:
%\item Two nodes in the value graph are congruent \iff the nodes have identical
%function labels and the corresponding heads of the edges leaving the nodes are
%congruent
%\end{itemize}
%
%\paragraph*{$O(N^2)$ algorithm}
%The algorithm checks all blocks to see if any should be split into two:
%when it discovers that two nodes in the same block which are not congruent.
%
%\begin{program}
%\PROC N^2-|partition|() \BODY
%    \pi_0 = \{B_0, B_1, ..., B_p\}
%    i = 0
%    |change| = true
%    \WHILE (|change|) \DO
%        |change| = false
%        k = 0
%        \FOREACH B_j | in | \pi_i \DO
%            v = |node from | B_j
%            |create a new block | B_k | in | \pi_{i+1}
%            |put | v | in | B_k | in | \pi_{i+1}
%            \FOREACH | node | w \in B_j \DO
%                \IF (|match|(v, w)) \AR*
%                    |add | w | to | B_k | in | \pi_{i+1}
%                \ELSE
%                    |change| = true
%                    |add | w | to | B_{k+1}
%                \FI
%            \OD
%        k \texttt{ += } 1
%    \OD
%    i \texttt{ += } 1
%\end{program}
%\negv
%\begin{program}
%\FUNCT |match|(|node | v, | node | w) \BODY
%    \FOR i = 1 | until the number of operands of | v \DO
%        a_v = |head of | i|-th edge of | v
%        a_w = |head of | i|-th edge of | w
%        \IF (a_v | and | a_w | belong to different blocks|) \AR*
%            \textbf{return } false
%        \FI
%    \OD
%    \textbf{return } true
%\end{program}
%
%\paragraph*{$O(N log N)$ algorithm}
%\begin{itemize}
%\item A block $B_j$ is split into two new blocks using $B_i$ such that\\
%$B_k = \{v \mid v \in B_j \land f(v) \in B_i\}$ and $B_{k+1} = \{v \mid v \in
%B_j \land f(v) \not\in B_i\}$
%\item For each block $B_i \subseteq S$, $f^{-1}(B) = \{v \mid f(v) \in B\}$
%\item A partition $\phi$ is safe with respect to a $T \subseteq S$ if for each
%block $B_i$ we have either $B_i \subseteq f^{-1}(T)$ or $B_i \ \cap f^{-1}(T) =
%\emptyset$
%\end{itemize}
%\negv
%\begin{program}
%\PROC |partitionValueGraph|() \BODY
%    |workList| = \{B_1, B_2,..., B_p\}
%    q = p
%    \WHILE (|workList| \not= \emptyset) \DO
%        |take a | B_i | from worklist|
%        \FOREACH | position | p | of a use of | x \in B_i \DO
%            |inverse| = \emptyset
%            \FOREACH x \in B_i \DO
%                |add all uses of | x | in position | p | to inverse|
%            \OD
%            \FOREACH j | such that | B_j \cap | inverse | \not= \emptyset \land \ B_j \not\subseteq |inverse| \DO
%                     q \texttt{ += } 1
%                     |create new class | B_q
%                     B_q = B_j \cap |inverse|
%                     B_j = B_j - B_q
%                     \IF (B_j \in |workList|)
%                        |add | B_q | to workList|
%                    \ELSE
%                        |add | min(B_j, B_q) | to workList|
%                    \FI
%            \OD
%        \OD
%    \OD
%\end{program}
%
%After a safe partition has been found, we apply:
%\begin{program}
%\PROC |dominatorBasedGVN|() \BODY
%    \FOREACH | block | B_i \in \pi \DO
%        \FOREACH |pair of nodes | (v, w) | in | B_i \times B_i \DO
%            \IF (v = w) \textbf{ continue} \FI
%            \IF (|def|[v] | dominates def|[w]) \AR*
%                |replace all uses of | w | by uses of | v
%                |remove def|[w]
%            \FI
%        \OD
%    \OD
%\end{program}
%
%\subsubsection*{Operator strength reduction - Induction variable elimination}
%The main purpose is to transform multiplications occurring inside a loop to
%additions.
%\begin{program}
%\PROC |operatorStrengthReduce|() \BODY
%    |dfsNumIndex| = 0
%    |stack| = |new Stack|
%    \FOREACH |vertex | v | in SSA Graph | \DO
%        \IF (|dfsNum|[v] = null) \AR*
%            strongConnect(v)
%        \FI \OD
%\end{program} \negv
%\begin{program}
%\PROC |strongConnect|(|vertex | v) \BODY
%    |dfsNum|[v] = |dfsNumIndex|
%    |lowLink|[v] = |dfsNumIndex|
%    |dfsNumIndex| \texttt{ += } 1
%    |stack|.|push|(v)
%    \FOREACH w | in | operands(v) \DO
%        \IF (|dfsNum|[w] = null) \AR*
%            |strongConnect|(w)
%            |lowLink|[v] = min(|lowLink|[v], |lowLink|[w])
%        \ELSIF (|dfsNum|[w] < |dfsNum|[v] \land |stack|.|contains|(w)) \AR*
%            |lowLink|[v] = min(|lowLink|[v], |dfsNum|[w]) \FI
%    \OD
%    \IF (|lowLink|[v] = |dfsNum|[v]) \AR*
%        |scc| = |new Set|
%        \DOW
%            w = |stack|.|pop|()
%            |scc|.|add|(w)
%        \ODW (w \not= v)
%        |processSCC|(|scc|)
%    \FI
%\end{program} \negv
%\begin{program}
%\PROC |processSCC|(|Set scc|) \BODY
%    \IF (|scc has a single member | n) \AR*
%        \IF (|validForm|(n)) \AR*
%            |replace|(n, iv, rc)
%        \ELSE
%            |header|[n] = \bot
%        \FI
%    \ELSE
%        |classify|(|scc|)
%\end{program} \negv
%\begin{program}
%\FUNCT |validForm|(n) \AR*
%    \IF (n | is of form | \texttt{x = iv $\times$ rc } (|or with | iv | and | rc | inverted|)
%         \lor \ n | is of form | \texttt{x = iv $\pm$ rc } (|or with | iv | and | rc | inverted|)
%         \textbf{return } true \FI
%    \textbf{return } false
%\end{program}\negv
%\begin{program}
%\PROC |replace|(|operation|, iv, rc) \BODY
%    |result| = |reduce|(|opCode|(operation), iv, rc)
%    |replace operation with mov using result as source|
%    |header|[|operation|] = |header|[iv]
%\end{program} \negv
%
%\begin{program}
%\FUNCT |reduce|(|operation|, iv, rc) \BODY
%    |result| = |lookup|(|opCode|, iv, rc)
%    \IF |result is not found| \AR*
%        |result| = |new temp|()
%        |install|(|opCode|, iv, rc, |result|)
%        |newDef| = |copyDef|(iv, |result|)
%        \FOREACH |operand | \omega | in newDef| \DO
%            \IF (\omega | is an induction variable |) \AR*
%                |replace | \omega | with reduce|(|opCode|, \omega, rc)
%            \ELSIF (|opCode| = \times \ \lor \ |newDef is a | \phi) \AR*
%                |replace | \omega | with apply|(|opCode|, \omega, rc)
%            \FI
%        \OD
%    \FI
%    \textbf{return } |result|
%\end{program} \negv
%\begin{program}
%\FUNCT |apply|(|opCode|, |op1|, |op2|) \BODY
%    |result| = |lookup|(|opCode|, |op1|, |op2|)
%    \IF |result is not found| \AR*
%        \IF |op1 is an induction variable | \land | op2 is a region constant| \AR*
%            |result| = |reduce|(|opcode|, |op1|, |op2|)
%        \ELSIF |op2 is an induction variable | \land | op1 is a region constant| \AR*
%            |result| = |reduce|(|opcode|, |op2|, |op1|)
%        \ELSE
%            |result| = |new temp|()
%            |install|(|opCode|, op1, op2, |result|)
%            |choose the location where the operation will be inserted|
%            |perform constant folding if possible|
%            |create a new operation at the chosen location|
%    \FI
%    \textbf{return } |result|
%\end{program} \pagebreak
%\begin{program}
%\PROC |classify|(|Set scc|) \BODY
%    \FOREACH n \in |scc| \DO
%        \IF (|rpo|[|vertex|(n)] < |rpo|[|header|]) \AR*
%            |header| = |vertex|(n)
%        \FI
%    \OD
%    \FOREACH n \in |scc| \DO
%        \IF (|operator|(n) \not\in \{\phi, +, -, |move|\}) \AR*
%            |sccIsInduction| = false
%        \ELSE
%            \FOREACH |operand | \omega \in |operands|(n) \DO
%                \IF (\omega \not\in |scc | \land \ !|regionConst|(\omega, |header|)) \AR*
%                    |sccIsInduction| = false
%                \ELSE
%                    |sccIsInduction| = true
%                    \textbf{break}
%                \FI
%            \OD
%        \FI
%    \OD
%    \IF (|sccIsInduction|) \AR*
%        \FOREACH n \in |scc| \DO
%            |header|[n] = |header|
%        \OD
%    \ELSE
%        \FOREACH n \in |scc| \DO
%            \IF (|validForm|(n)) \AR*
%                |replace|(n, iv, rc)
%            \ELSE
%                |header|(n) = \bot
%            \FI
%        \OD
%    \FI
%\end{program} \negv
%\begin{program}
%\FUNCT |regionConst|(x, |header|) \BODY
%    \textbf{return } x | is constant | \lor | vertex|(x) | strictly dominates header |
%\end{program}\negv

\end{document}

