\documentclass[a4paper,12pt, notitlepage]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{program}
\usepackage{color}

\renewcommand{\o}{\lor}
\newcommand{\gge}{\ \underline{\gg}\ }
\newcommand{\no}{\neg}
\newcommand{\eq}{\equiv}
\newcommand{\nq}{\not\equiv}
\newcommand{\tq}{\mid}
%\newcommand{\impl}{\Rightarrow}
\newcommand{\conseq}{\Leftarrow}
\newcommand{\existe}[3]{(\exists #1 \mid #2 : #3)}
\newcommand{\patodo}[3]{(\forall #1 \mid #2 : #3)}
\newcommand{\cgen}[4]{(#1 #2 \mid \ #3 : #4)}
\newcommand{\sust}[3]{#1 [#2 := #3]}
\newcommand{\nolibre}[2]{\no \textit{ocurre-libre}('#1', '#2')}
\newcommand{\range}[3]{#1 \leq #2 < #3}

\renewcommand{\iff}{\textbf{ iff }}

\newcommand{\ind}[1]{\hspace*{#1 cm}}
\newcommand{\negv}{\vspace{-0.7cm}}

\begin{document}

\begin{center}

{\Large{Study Guide\\ \bigskip
			Optimising Compilers @ Lunds Universitet}}
\vspace{1cm}
\end{center}
\section*{Basics}
\subsubsection*{Lattice}
It's a partially ordered set where every pair has least upper and greatest lower
bounds (infimum and supremum) which are unique. They are called the
\textit{meet} ($\land$) and \textit{join} ($\lor$), respectively.

\subsubsection*{Tarjan's algorithm for Strongly Connected Components}
\negv
\begin{program}
\PROC |tarjan|() \BODY
    |components| = |new Set|
    |dfsNumIndex| = 0
    |stack| = |new Stack|
    \FOREACH |vertex | v | in | V \DO
        \IF (|dfsNum|[v] = null) \AR*
            strongConnect(v)
        \FI \OD
\end{program} \negv
\begin{program}
\PROC |strongConnect|(|vertex | v) \BODY
    |dfsNum|[v] = |dfsNumIndex|
    |lowLink|[v] = |dfsNumIndex|
    |dfsNumIndex| \texttt{ += } 1
    |stack|.|push|(v)
    \FOREACH w | in | succ(v) \DO
        \IF (|dfsNum|[w] = null) \AR*
            |strongConnect|(w)
            |lowLink|[v] = min(|lowLink|[v], |lowLink|[w])
        \ELSIF (|dfsNum|[w] < |dfsNum|[v] \land |stack|.|contains|(w)) \AR*
            |lowLink|[v] = min(|lowLink|[v], |dfsNum|[w]) \FI
    \OD
    \IF (|lowLink|[v] = |dfsNum|[v]) \AR*
        |scc| = |new Set|
        \DOW
            w = |stack|.|pop|()
            |scc|.|add|(w)
        \ODW (w \not= v)
        |components|.|add|(|scc|)
    \FI
\end{program}

\section*{Dominance Analysis}
\subsubsection*{Compute dominance}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gge w $ \iff every path from $s$ to $w$ includes $v$. 
\\ $v$ \textbf{dominates} $w$.
\item $dom(w) = \{v \mid v \gge w\}$
\item $\gge$ is a partial order relation. 
\item $u \gge v$ \iff $u \gge p_i$ for every $p_i \in pred(v)$
\item $dom(w) = \{w\} \cup \displaystyle \bigcap_{p \in pred(w)} dom(p)$
\end{enumerate}
\vspace{-0.5cm}
\paragraph*{Algorithm}
\begin{program}
\PROC |computeDominance|() \BODY
    |dom|[s] = \{s\}
    \FOREACH |vertex | v | in | V | except | s \DO
        |dom|[v] = V \OD
    \WHILE |some dom|[v] | has changed| \DO
        \FOREACH |vertex | v | in | V | except | s \DO
            |dom|[v] = \{v\} \cup \displaystyle \bigcap_{p \in pred(v)} |dom|[p]
            \OD
    \OD
\end{program}
\subsubsection*{Lenguaer-Tarjan Algorithm (Dominator Tree)}
\paragraph*{Theory}
\begin{enumerate}
\item $v \gg w $ \iff $v \gge w \land v \not= w$
\\ $v$ \textbf{strictly dominates} $w$.
\item $v \in dom(w) \land u \in dom(w) \Rightarrow u \gge v \lor v \gge u$
\item $v = iDom(w)$ \iff $v \gg w \land \patodo{u}{u \gg w}{v \not\gg u}$
\\ $v$ \textbf{is the immediate dominator of} $w$.
\item The graph of the reflexive and transitive closure of the dominance
relation is a  tree, called the dominator tree (DT). $(u,v) \in DT$ 
\iff $u = iDom(v)$.
\item $u \gge v$ \iff $dfsNum(u) \leq dfsNum(v) \land \\ 
dfsNum(v) \leq dfsNum(u) + numberOfDescendants(u)$
\item $v = sDom(w)$ \iff $v$ is the smallest vertex by $dfsNum$ such that there
is a path $(v, u_1, u_2, ..., u_{k-1}, w)$ with $dfsNum(u_i) > dfsNum(w)$.
\\ The semidominator is frequently equal to the immediate dominator.
\end{enumerate}

\paragraph*{Algorithm}
$parent$ is the parent in the DFS tree after calling $dfs()$.
\begin{program}
\PROC |lenguaerTarjan|() \BODY
    |emptyBuckets()|
    |setSdominatorsToSelf()|
    |dfs()|
    \FOREACH |vertex | v | in reverse | dfsNumber | order| \DO
        \FOREACH |predecessor | p | of | v \DO
            u = |ancestorWithLeastSdom(p)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[v])) \AR*
                |sDom|[v] = |sDom|[u] 
            \FI
        \OD
        |bucket|[|sDom|[v]].add(v)
        |ancestor|[v] = |parent|(v) 
        \FOREACH |vertex | b| in bucket|[|parent|(v)] \DO
            |remove b|
            u = |ancestorWithLeastSdom(b)|
            \IF (|dfsNum|(|sDom|[u]) < |dfsNum|(|sDom|[b])) \AR*
                |iDom|[b] = u
            \ELSE
                |iDom|[b] = |parent|(v)
            \FI
        \OD
    \OD
    \FOREACH |vertex | v | except | s \DO
        \IF |iDom|[v] \not= |sDom|[v] \AR*
            |iDom|[v] = |iDom|[|iDom|[v]]
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |ancestorWithLeastSdom|(|vertex |w) \BODY
    |go through the ancestor chain of | w
    |return ancestor with the least sDom|
\end{program}

\section*{Loop Analysis}
\subsubsection*{Basics}
\begin{enumerate}
\item A loop is a subgraph of the CFG that is a strongly connected component
\item An entry loop is a vertex with a predecessor that is not in the loop
\item Irreducible loops have multiple entry points
\item Reducible or natural loops only have one entry point: the loop header. 
It dominates all other vertices in the loop.
\end{enumerate}
\negv
\begin{program}
\PROC |identifyNaturalLoops|() \BODY
    \FOREACH |back edge | (v, w) | of | G \DO
        \IF (w.|dominates|(v)) \AR*
            |search backwards all paths from | v | to | w.
            |the visited vertices belong to the natural loop|
        \FI
    \OD
\end{program}

\section*{Dataflow Analysis}
\subsubsection*{Basics}
\begin{itemize}
\item It is concerned with how a procedure uses and defines its variables and 
expressions
\item Every assignment statement is given an index
\item Local analysis discovers what happens within a vertex: its output is
$gen(v)$ and $kill(v)$
\item Global analysis: each vertex has $in(v)$ and $out(v)$ in addition to $gen$
and $kill$.
\end{itemize}
\begin{tabular}{ll}
$in(v)$ & definitions reaching the beginning of $v$ \\
$out(v)$ & definitions reaching the end of $v$ \\
$gen(v)$ & definitions generated in $v$ \\
$kill(v)$ & definitions killed in $v$ \\
\end{tabular}

\begin{program}
\PROC |reachingDefs|() \BODY
    |workList| = |vertices in reverse postorder|
    \WHILE |workList is not empty| \DO
        v = |workList|.|first|()
        |old| = |out|[v]
        |in|[v] = \displaystyle \bigcup_{p \in pred(v)} |out|[p]
        |out|[v] = |gen|[v] \cup (|in|[v] - |kill|[v])
        \IF (|old| \not= |out|(v)) \AR*
            \FOREACH |succesor | s | of | v \DO
                \IF (s | is not in workList|) \AR* 
                    |workList|.|add|(s)
                \FI
            \OD
        \FI
    \OD
\end{program}
\negv
\begin{program}
\PROC |localLiveAnalysis|() \BODY
    \FOREACH |vertex | v \DO
        \FOREACH |statement | s \DO
            \FOREACH |used variable | x | of | s \DO
                \IF (x \not\in |kill|[v]) \AR*
                   |use|[v].|add|(x)
                \FI
            \OD
            \FOREACH |defined variable | x | of | s \DO
                \IF (x \not\in |gen|[v]) \AR*
                   |kill|[v].|add|(x)
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |globalLiveAnalysis|() \BODY
    \WHILE |some in|[v] | has changed| \DO
        \FOREACH |vertex v | \DO
            |out|[v] = \displaystyle \bigcup_{s \in succ(v)} |in|[s]
            |in|[v] = |use|[v] \cup (|out|[v] - |kill|[v])
        \OD
    \OD
\end{program}

\section*{Static Single Assignment Form}
\begin{itemize}
\item Every variable is defined as most once (statically)
\item $\phi$-functions: one argument for each predecessor at some join vertices
\end{itemize}

\subsubsection*{Dominance Frontiers}
\paragraph*{Theory}
\begin{enumerate}
\item $DF(v) = \{w \mid \existe{p}{p \in pred(w)}{v \gge p \land v \not\gg w}\}$
\\ the \textbf{dominance frontier of vertex v}
\\ the set of vertices $w$ such that $v$ dominates a predecessor of $w$, but does
not strictly dominate $w$.
\\ if $v$ dominates a predecessor of $w$ but does not strictly dominate $w$,
    then $w$ is in the dominance frontier of $v$.
\item $DF_{local}(v) = \{w \in succ(v) \mid v \not\gg w\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(v) \not\gg w\}$
\item $DF(v) = DF_{local}(v) \cup 
    \displaystyle \bigcup_{w \in children(v)} DF_{up}(w)$
\item $DF_{local}(v) = \{w \in succ(v) \mid iDom(w) \not= v\}$
\item $DF_{up}(v) = \{w \in DF(v) \mid iDom(w) \not= v\}$
\end{enumerate}

\paragraph*{Algorithm}
\begin{program}
\PROC |dominanceFrontiers|() \BODY
    \FOREACH | vertex | v | in a postorder traversal of DT | \DO
        |dominanceFrontier|[v] = |new Set|
        \FOREACH | vertex | w | in succ|(v) \DO
            \IF (|iDom|(w) \not= v) \AR*
                |dominanceFrontier|[v].|add|(w)
            \FI
        \OD
        \FOREACH | vertex | w | in children|(v) \DO
            \FOREACH | vertex | u | in dominanceFrontier|[w] \DO
                \IF (iDom(u) \not= v) \AR*
                    |dominanceFrontier|[v].|add|(u)
                \FI
            \OD
        \OD
    \OD
\end{program}

\subsubsection*{Insertion of $\phi$-functions}
\paragraph*{Theory}
\begin{enumerate}
\item Two paths $p = (v_0, ..., v_X)$ and $q = (w_0, ..., w_Y)$
\textbf{converge} at $u$ \iff
    \begin{enumerate}
        \item $v_0 \not= w_0$
        \item $v_X = w_Y = u$
        \item $(u_i = v_j) \Rightarrow i = X \lor j = Y$
    \end{enumerate}
\item Given a set $A$ of vertices, the join of $A$ ($J(A)$) is the set of all
vertices $w$ such that there are two distinct vertices $u$ and $v$ in $A$ with
paths which converge at $w$.
\item $J_{i+1}(A) = J(A \cup J_{i}(A))$, $J^+(A)$ is the fixed-point.
\item $DF$ can be applied to sets of vertices, mapping $DF$ over all the
vertices of its argument.
\item $DF_{i+1}(A) = DF(A \cup DF_{i}(A))$, and $DF^+(A) = J^+(A)$.
\item The set of vertices which need $\phi$-functions for any variable $v$
is the iterated dominance frontier $DF_+(A)$, where $A$ is the set of vertices
with assignment statements to $v$.
\end{enumerate}

\pagebreak
\paragraph*{Algorithm}
\begin{program}
\PROC |insert_|\phi() \BODY
    |iteration| = 0
    \FOREACH | vertex | v \DO
        |hasAlready|[v] = 0
        |work|[v] = 0
    \OD
    W = |new Set|
    \FOREACH | variable | x \DO
        |iteration| \texttt{ += } 1
        \FOREACH | vertex | v \in A(x) \DO
            |work|[v] = |iteration|
            W.|add|(v)
        \OD
        \WHILE (W | is not empty|) \DO 
            v = |take vertex from | W
            \FOREACH w | in | DF(v) \DO
                \IF (|hasAlready|[w] < |iteration|) \AR*
                    |place | x = \phi(x,...,x) | at | w
                    |hasAlready|[w] = |iteration|
                    \IF (|work|[w] < |iteration|) \AR*
                        |work|[w] = |iteration|
                        W.|add|(w)
                    \FI
                \FI
            \OD
        \OD
    \OD
\end{program}
\negv
\begin{program}
\PROC |renameVariables|() \BODY
    \FOREACH | variable | x \DO
        |C|[x] = 0
        |S|[x] = |new Stack|
    \OD
    |search|(s) \hspace{1cm} \texttt{// s = the start vertex}
\end{program}
\pagebreak
\begin{program}
\PROC |search|(|vertex | v) \BODY
    \FOREACH | assignment statement | s | in | v \DO
        \FOREACH | variable | x | in | RHS(s) \DO
            i = |S|[x].|top|()
            |replace use of | x | by use of | x_i
        \OD
        \FOREACH | variable | x | in | LHS(s) \DO
            i = |C|[x]
            |replace | x | by | x_i
            |S|[x].|push|(i)
            |C|[x] \texttt{ += } 1
        \OD
    \OD
    \FOREACH w | in | succ(v) \DO
        j = |which predecessor is v to w? | \hspace{1cm} \texttt{// first, second, ... ?}
        \FOREACH \phi|-function in | w \DO
            i = |S|[x].|top|()
            |replace use of the | j |-th operand in | RHS(\phi) | by use of | x_i
        \OD
    \OD
    \FOREACH w | in children|(v) \DO
        |search|(w)
    \texttt{// pop every variable version pushed in v}
    \FOREACH |assignment statement | s | in |v \DO
        \FOREACH | variable | x | in | oldLHS(s) \DO
            |S|[x].|pop|()
        \OD
    \OD
\end{program}

\section*{SSA Optimisation}
\subsubsection*{Partial Redundancy Elimination (PRE)}
\paragraph*{Basics}
\begin{itemize}
\item Attempt to calculate expressions only once
\item Partial redundancy: one of the expressions is inside an \texttt{if-else}
\pagebreak
\item Case examples
    \begin{enumerate}
        \item 
        \begin{verbatim}
if (a * b > max)
    max = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
if (t > max)
    max = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition)
    x = a * b
y = a * b
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    t = a * b
    x = t
}
else
    t = a * b
y = t
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \pagebreak
        \item 
        \begin{verbatim}
do {
    x += a * b
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
t = a * b
do {
    x += t
}
while (x < y)
        \end{verbatim} \vspace{-0.5cm}
        \item 
        \begin{verbatim}
if (condition) {
    // some code
    y = x + 4
}
else {
    // other code
}
z = x + 4
        \end{verbatim} \vspace{-0.5cm}
        is translated into...
        \begin{verbatim}
if (condition) {
    // some code
    t = x + 4
    y = t
}
else {
    // other code
    t = x + 4
}
z = t
        \end{verbatim}
            
            

    \end{enumerate}
\item Loop improvement 
\item Global value numbering can optimise code that PRE cannot
\item Common subexpression elimination and code motion of loop invariants are
subsumed by PRE
\end{itemize}

\paragraph*{Theory}
\begin{enumerate}
\item Two operands $a_j$ and $b_k$ are equal \iff $a = b$
\item A computation $E_1$ at some point in the program is an occurrence of
computation $E$ if both perform the same operation and have equal operands
\item A computation $E$ is preserved along a path $P$ if $P$ contains nothing
that may alter the value of $E$.
\item If $E_1$ and $E_2$ are occurrences of $E$, and there is a path in the
program from $E_1$ to $E_2$ which preserves $E$, then $E_2$ is said to be
redundant with respect to $E_1$.
\item If $p$ is a point in the program and there is a path from $p$ to $E_1$
which preserves $E$ and contains no occurrence of $E$ between $p$ and $E_1$, 
$E_1$ is exposed with respect to $p$.
\item The set of occurrences to which $E_0$ is both redundant and exposed is
denoted $\Omega$.
\item The set of alterations of the value of $E$ is denoted $A$ (remember
        translation to SSA-form).
\item A vertex $v$ in $G$ is a $\phi$-vertex for $E_0$ \iff
    \begin{itemize}
        \item The beginning of $v$ dominates $E_0$
        \item There exist distinct $u_1$, $u_2 \in \Omega \cup A$ and paths $p_1$ 
        and $p_2$ such that $u_1$ is contained in the first vertex of $p_1$, 
        $u_2$ is contained in the first vertex of $p_2$, and $p_1$ and $p_2$
        converge in $v$.
    \end{itemize}
\item An occurrence is \textbf{real} if it corresponds to code in the program,
    $\phi$ if it is a $\phi$-function.
\item A computation $E$ is partially available at point $p$ in the program if
there is a path from a real occurrence of the computation to $p$ that preserves
$E$.
\item A computation $E$ is fully available at point $p$ in the program if it is
partially available from every path from program entry $s$ to $p$.
\item An occurrence $E_0$ is partially redundant if $E$ is partially available
just before $E_0$
\item An occurrence $E_0$ is fully redundant if $E$ is fully available
just before $E_0$
\item Analogous: partially and fully anticipated
\item A placement is safe if all inserted real occurrences of a computation are
fully anticipated or fully available
\item A placement is computationally optimal if no safe placement can result in
fewer occurrences of the computation along any path from entry to exit in the
program
\end{enumerate}

\paragraph*{Algorithm} 
\paragraph*{$\phi$-insertion}
A $\phi$ is needed whenever two different values of $E$ reach a common point in
the program. Therefore, there are two sets of vertices in whose iterated
dominance frontier we will insert $\phi$-functions: the set $R$ of real
occurrences of $E$ and the set $A$ of vertices with assignments to an operand of
$E$. An assignment to an operand of $E$ is a computation of $E$ which produces
the value $\bot$. 

\textbf{Thus, we insert a $\phi$ at the beginning of every vertex in
$DF^+(R) \cup DF^+(A)$}.

An \textbf{evaluation} of a computation $E$ is either a real occurrence, a
$\phi$ occurrence or an assignment to an operand of $E$.

\paragraph*{Renaming}
Two occurrences of $E$ with the same version number have equal values. 
The algorithm is based on the rename algorithm for the translation to SSA form.
There are stacks for versions of the variables and stacks for versions of each
computation.

\pagebreak
\begin{program}
|preOrderTraversalOfTheDominatorTree()|
|when an occurrence | o | of | E | is encountered: |
\IF (o | is a |\phi| occurrence| ) \AR*
    |a new version is created|
    |\textbf{return}|
\FI
|compare the occurrence on top of the stack of | E
|with the top of the stack of each operand in the computation |
\IF (o |is a real occurrence | \land |all the versions match|) \AR*
    |add an upward edge in the factored redundancy graph|
    |from the occurrence to the top of the computation stack|
\ELSIF (o |is a real occurrence | \land |some version doesn't match|) \AR*
    |a new version is assigned to the occurrence|
\ELSE 
    \texttt{// the occurrence is a $\phi$ operand}
    |assign the occurrence the special version |\bot
\FI

\end{program}

\begin{itemize}
\item 
\end{itemize}

%Hashbased value number
%Global value numbering
%Ssa pre (partial redundancy elimination)
\end{document}

